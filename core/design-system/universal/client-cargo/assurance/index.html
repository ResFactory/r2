<!DOCTYPE html>
<html lang="en" data-universal-test-hook-fn="universalTestHookFn">

<head>
    <meta charset="utf-8" />
    <title>Universal Client Cargo Assurance Engineering</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="https://unpkg.com/mocha/mocha.css" />
    <script>
        function universalTestHookFn(flexibleArgsResult) {
            flexibleArgsResult.args.hooked = "universalTestHookFn";
            return flexibleArgsResult;
        }
    </script>
</head>

<body>
    <p style="text-align: center;"><a href="#" onclick="location.reload()">Rerun tests</a></p>
    <div id="mocha"></div>

    <script src="https://unpkg.com/chai/chai.js"></script>
    <script src="https://unpkg.com/mocha/mocha.js"></script>

    <script type="module">
        mocha.setup('bdd');
        mocha.checkLeaks();
        import {
            jsTokenEvalResult,
            humanFriendlyPhrase,
            detectFileSysStyleRoute,
            flexibleArgs,
            governedArgs,
            EventEmitter,
            inspectUrlHttpHeaders,
            httpEndpointAvailableAction
        } from "./deps.auto.js";

        const assert = chai.assert;

        const syntheticScalarHook = "synthetic";
        const syntheticArrayHook = ["synthetic"];
        const syntheticObjectHook = { synthetic: "yes" };
        function syntheticFunctionHook() { }
        class SyntheticClassHook { }

        describe("universal-eval", () => {
            const igoreResult = () => { };
            const evalInThisScope = (js) => eval(js);

            it("jsTokenEvalResult (invalid)", () => {
                let badValues = 0;
                jsTokenEvalResult("alert('potential attack foiled!'))", eval, igoreResult, () => { badValues++ });
                jsTokenEvalResult("badFunction", eval, igoreResult, undefined, (error) => { badValues++ });
                assert(badValues == 2);
            });

            it("jsTokenEvalResult (class)", () => {
                const synthetic = jsTokenEvalResult("SyntheticClassHook", evalInThisScope);
                assert(synthetic === SyntheticClassHook);
            });

            it("jsTokenEvalResult (function)", () => {
                const synthetic = jsTokenEvalResult("syntheticFunctionHook", evalInThisScope);
                assert(synthetic === syntheticFunctionHook);
            });

            it("jsTokenEvalResult (values)", () => {
                let synthetic = jsTokenEvalResult("syntheticScalarHook", evalInThisScope);
                assert(synthetic === syntheticScalarHook);
                synthetic = jsTokenEvalResult("syntheticArrayHook", evalInThisScope);
                assert(synthetic === syntheticArrayHook);
                synthetic = jsTokenEvalResult("syntheticObjectHook", evalInThisScope);
                assert(synthetic === syntheticObjectHook);
            });
        });

        describe("universal-text", () => {
            it("humanizeText", () => {
                const inhumanText = "module-2_Component--_  1,=service_2";
                const result = humanFriendlyPhrase(inhumanText);
                assert(result == "Module 2 Component 1 Service 2");
            });
        });

        describe("universal-parser", () => {
            it("detectFileSysStyleRoute", () => {
                const complexPath =
                    "/some/long-ugly/file_sys_path/module-2_Component--_  1,=service_2.md";
                const result = detectFileSysStyleRoute(complexPath);
                assert(result.dir == "/some/long-ugly/file_sys_path");
                assert(result.base == "module-2_Component--_  1,=service_2.md");
                assert(result.name == "module-2_Component--_  1,=service_2");
                assert(result.modifiers.length == 0);
                assert(result.ext == ".md");
            });

            it("detectFileSysStyleRoute with modifiers", () => {
                const complexPath =
                    "/some/long-ugly/file_sys_path/module-2_Component--_  1,=service_2.mod1.mod2.md";
                const result = detectFileSysStyleRoute(complexPath);
                assert(result.root == "/");
                assert(result.dir == "/some/long-ugly/file_sys_path");
                assert(result.base == "module-2_Component--_  1,=service_2.mod1.mod2.md");
                assert(result.name == "module-2_Component--_  1,=service_2");
                assert(result.modifiers.length == 2);
                assert(result.ext == ".md");
            });
        });

        describe("universal-args", () => {
            it("flexibleArgs with no supplied args and rules object", () => {
                const result = flexibleArgs(undefined, { defaultArgs: { test: "value" } });
                assert(result);
                assert(typeof result === "object");
                assert(result.args.test == "value");
                assert(result.rules.defaultArgs.test == "value");
            });

            it("flexibleArgs with supplied args and rules function", () => {
                const result = flexibleArgs(
                    { another: "value" },
                    () => ({ defaultArgs: { fromDefaults: "value" } }));  // rules can be a function
                assert(result.args.fromDefaults == "value");
                assert(result.args.another == "value");
                assert(result.rules.defaultArgs.fromDefaults == "value");
            });

            it("flexibleArgs with supplied args function and rules function", () => {
                const result = flexibleArgs(
                    (defaults) => ({ ...defaults, another: "value" }), // if argsSupplier is a function, very important that ...defaults is spread
                    () => ({ defaultArgs: (rules, args, argsSupplier) => ({ test: "value" }) }));       // rules can be a function, and so can defaultArgs
                assert(result.args.test == "value");    // from defaultArgs
                assert(result.args.another == "value"); // from argsSupplier
            });

            it("flexibleArgs with supplied args object and hookable DOM function", () => {
                let hookable = undefined;
                let hook = undefined;
                const result = flexibleArgs({ test: "value" }, {
                    finalizeResult: (suggested) => {
                        // find the first hook available in the DOM
                        hookable = document.querySelector("[data-universal-test-hook-fn]");
                        if (hookable) {
                            // a hook name was found, see if it's a valid token and "execute" it
                            hook = jsTokenEvalResult(hookable.dataset.universalTestHookFn, (jsToken) => eval(jsToken));
                            if (hook) return hook(suggested);
                        }
                        // be sure to return the original otherwise failure is likely
                        return suggested;
                    },
                });
                assert(result);
                assert(hookable === document.documentElement);
                assert(hook === universalTestHookFn);
                assert(result.args.test == "value");
                assert(result.args.hooked == "universalTestHookFn");
            });

            it("governedArgs", () => {
                governedArgs({ test: "value" }, {
                    hookableDomElemsAttrName: "universal-test-hook-fn",
                    consumeArgs: ({ args }) => {
                        assert(args.test == "value");
                    }
                });
            });
        });

        describe("universal-event-emitter", () => {
            it("flexibleEventEmitter", () => {
                const ee = new EventEmitter();
                const testE1 = "testE1";
                const events = [];
                ee.on(testE1, (event) => {
                    events.push(event);
                });
                ee.emit(testE1, { first: true });
                ee.emit(testE1, { second: true });
                assert(events.length == 2);
                assert(events[0].first);
                assert(events[1].second);
            });
        });

        describe("universal-HTTP", () => {
            it("inspectUrlHttpHeaders", () => {
                inspectUrlHttpHeaders({
                    onHeaders: (headers) => {
                        assert(headers);
                        assert(typeof headers === "object");
                    },
                    onHeader: {
                        "content-length": (value, key, alias, url) => {
                            assert(key == "content-length");
                            assert(value > 0);
                            assert(alias == "contentLength");
                            assert(url);
                        },
                        "contentLength": (value, key, alias, url) => {
                            assert(key == "contentLength");
                            assert(value > 0);
                            assert(alias == "content-length");
                            assert(url);
                        },
                    }
                });
            });

            it("httpEndpointAvailableAction", () => {
                httpEndpointAvailableAction("/", (httpEAA) => {
                    // console.log("action", event);
                }, {
                    onInvalidStatus: (event) => {
                        // console.log("onInvalidStatus", event);
                    }
                });
            });
        });

        mocha.run();
    </script>
</body>

</html>