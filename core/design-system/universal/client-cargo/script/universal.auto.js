// deno-fmt-ignore-file
// deno-lint-ignore-file
// Code generated by bundle-js.ts Deno.emit(universal.js.ts). DO NOT EDIT.

const jsTokenEvalRE = /^[a-zA-Z0-9_]+$/;
function jsTokenEvalResult(identity, discover, isTokenValid, onInvalidToken, onFailedDiscovery) {
    let result;
    if (identity.match(jsTokenEvalRE)) {
        try {
            if (Array.isArray(discover)) {
                for (const te of discover){
                    result = te(identity);
                    if (result) break;
                }
            } else {
                result = discover(identity);
            }
            if (result && isTokenValid) result = isTokenValid(result, identity);
        } catch (error) {
            result = onFailedDiscovery?.(error, identity);
        }
    } else {
        result = onInvalidToken?.(identity);
    }
    return result;
}
const jsTokenEvalResults = {};
function cacheableJsTokenEvalResult(name1, discover = eval, onInvalidToken, onFailedDiscovery) {
    if (name1 in jsTokenEvalResults) return jsTokenEvalResults[name1];
    return jsTokenEvalResult(name1, discover, (value, name)=>{
        jsTokenEvalResults[name] = value;
        return value;
    }, onInvalidToken, onFailedDiscovery);
}
function flexibleArgs(argsSupplier, rulesSupplier) {
    const rules = rulesSupplier ? typeof rulesSupplier === "function" ? rulesSupplier(argsSupplier) : rulesSupplier : undefined;
    const defaultArgsSupplier = rules?.defaultArgs ?? {};
    const defaultArgs = typeof defaultArgsSupplier === "function" ? defaultArgsSupplier(argsSupplier, rules) : defaultArgsSupplier;
    let args = typeof argsSupplier === "function" ? argsSupplier(defaultArgs, rules) : argsSupplier ? {
        ...defaultArgs,
        ...argsSupplier
    } : defaultArgs;
    if (rules?.argsGuard) {
        if (!rules?.argsGuard.guard(args)) {
            args = rules.argsGuard.onFailure(args, rules);
        }
    }
    let result = {
        args,
        rules
    };
    if (rules?.finalizeResult) {
        result = rules.finalizeResult(result);
    }
    return result;
}
function governedArgs(argsSupplier, rulesSupplier) {
    const result = flexibleArgs(argsSupplier, rulesSupplier);
    return result;
}
export { jsTokenEvalResult as jsTokenEvalResult };
export { cacheableJsTokenEvalResult as cacheableJsTokenEvalResult };
export { flexibleArgs as flexibleArgs };
export { governedArgs as governedArgs };
function httpEndpointAvailableAction(url1, action, state) {
    const prepareHttpRequest = (url, state)=>{
        const http = new XMLHttpRequest();
        http.open("HEAD", url, true);
        http.setRequestHeader("Content-Type", "text/plain");
        return http;
    };
    const http1 = state?.prepareXMLHttpRequest ? state.prepareXMLHttpRequest(url1, state) : prepareHttpRequest(url1, state);
    http1.onreadystatechange = function(xhrEvent) {
        if (http1.readyState == 4) {
            if (http1.status == 200) {
                action({
                    request: http1,
                    url: url1,
                    xhrEvent,
                    state
                });
            } else {
                if (state?.onInvalidStatus) {
                    state.onInvalidStatus({
                        request: http1,
                        url: url1,
                        xhrEvent,
                        state
                    });
                }
            }
        }
    };
    try {
        http1.send(null);
    } catch (error) {
        if (state?.onError) {
            if (state?.onInvalidStatus) {
                state.onInvalidStatus({
                    request: http1,
                    url: url1,
                    xhrEvent,
                    state,
                    error
                });
            }
        }
    }
}
export { httpEndpointAvailableAction as httpEndpointAvailableAction };
class LabeledBadge {
    remoteBaseURL;
    useBadgenLib;
    importModule;
    #initialized = false;
    #isBadgenLibLoaded = false;
    autoHTML;
    constructor(argsSupplier){
        const { args  } = governedArgs(argsSupplier, {
            defaultArgs: {
                remoteBaseURL: 'https://badgen.net/badge',
                importModule: (lib, actuate)=>import(lib).then(actuate)
                ,
                useBadgenLib: true
            }
        });
        this.remoteBaseURL = args.remoteBaseURL;
        this.useBadgenLib = args.useBadgenLib;
        this.importModule = args.importModule;
    }
    badgenArgs(args) {
        const badgenArgs = {
            status: args.status || "status",
            ...args
        };
        return args?.enhanceBadgen ? args.enhanceBadgen(badgenArgs) : badgenArgs;
    }
    badgenRemoteURL(badgenArgs) {
        const badge = this.badgenArgs(badgenArgs);
        return `${this.remoteBaseURL}/${badge.label}/${badge.status}/${badge.color}`;
    }
    decorateHTML(badgenArgs, html) {
        if (badgenArgs.elaborationText) {
            html = `<span title="${badgenArgs.elaborationText}">${html}</span>`;
        }
        if (badgenArgs.actionable) {
            html = `<a onclick="${badgenArgs.actionable}">${html}</a>`;
        }
        return html;
    }
    badgenRemoteImageHTML(badgenArgs) {
        return this.decorateHTML(badgenArgs, `<img src="${this.badgenRemoteURL(badgenArgs)}">`);
    }
    init() {
        if (this.#initialized) return this;
        this.autoHTML = (badgenArgs)=>{
            return this.badgenRemoteImageHTML(badgenArgs);
        };
        if (this.useBadgenLib) {
            this.importModule("https://unpkg.com/badgen", ()=>{
                this.autoHTML = (badgenArgs)=>{
                    return this.decorateHTML(badgenArgs, badgen(this.badgenArgs(badgenArgs)));
                };
                this.#isBadgenLibLoaded = true;
            });
        }
        this.#initialized = true;
        return this;
    }
    get isBadgenLibLoaded() {
        return this.#isBadgenLibLoaded;
    }
}
class TunnelStatePresentation {
    static defaultInitialStatus = "inactive";
    summaryBadgeDomID;
    elaborationHtmlDomID;
    constructor(argsSupplier){
        const { args  } = governedArgs(argsSupplier, {
            defaultArgs: {
                summaryBadgeDomID: "rf-universal-tunnel-state-summary-badge",
                elaborationHtmlDomID: "rf-universal-tunnel-state-elaboration",
                initialStatus: TunnelStatePresentation.defaultInitialStatus,
                labeledBadge: new LabeledBadge().init(),
                defaultLabel: "Tunnel"
            }
        });
        this.summaryBadgeDomID = args.summaryBadgeDomID;
        this.elaborationHtmlDomID = args.elaborationHtmlDomID;
        this.labeledBadge = args.labeledBadge;
        this.defaultLabel = args.defaultLabel;
    }
    badgenArgs(state, options) {
        const status = state.status;
        const label = options?.label ?? this.defaultLabel;
        const color = options?.color ?? (status == "inactive" ? 'red' : status == "active" ? 'green' : 'orange');
        const icon = options?.icon;
        return this.labeledBadge.badgenArgs({
            label,
            labelColor: '555',
            status,
            color,
            style: 'classic',
            icon,
            iconWidth: 13,
            scale: 1,
            ...options
        });
    }
    update(state, options) {
        const tspElem = document.getElementById(this.summaryBadgeDomID);
        if (tspElem) {
            tspElem.innerHTML = this.labeledBadge.autoHTML(this.badgenArgs(state, options));
        } else {
            console.warn(`Tunnel state could not be updated: DOM element id='${this.summaryBadgeDomID}' was not found.`);
        }
    }
    display(state = true) {
        if (this.summaryBadgeElement) {
            this.summaryBadgeElement.style.display = state ? 'block' : 'none';
        }
    }
    get summaryBadgeElement() {
        return document.getElementById(this.summaryBadgeDomID);
    }
    get elaborationHtmlElement() {
        return document.getElementById(this.elaborationHtmlDomID);
    }
    get isStatisticsPresentationPossible() {
        return this.labeledBadge.isBadgenLibLoaded;
    }
}
class TunnelReconnectStrategy {
    static UNKNOWN = 0;
    static WAITING = 1;
    static TRYING = 2;
    static COMPLETED = 3;
    static ABORTED = 4;
    connect;
    report;
    maxAttempts;
    #attempt;
    #interval;
    #status = TunnelReconnectStrategy.UNKNOWN;
    constructor(connect, report, maxAttempts = 15){
        this.connect = connect;
        this.report = report;
        this.maxAttempts = maxAttempts;
        this.#attempt = 0;
    }
    get attempt() {
        return this.#attempt;
    }
    get status() {
        return this.#status;
    }
    set status(value) {
        this.#status = value;
        this.report(this);
    }
    get statusText() {
        switch(this.#status){
            case TunnelReconnectStrategy.UNKNOWN:
                return "unknown";
            case TunnelReconnectStrategy.WAITING:
                return "waiting";
            case TunnelReconnectStrategy.TRYING:
                return `reconnecting ${this.#attempt}/${this.maxAttempts}`;
            case TunnelReconnectStrategy.COMPLETED:
                return "reconnected";
            case TunnelReconnectStrategy.ABORTED:
                return "aborted";
        }
        return "?";
    }
    reconnect() {
        this.status = TunnelReconnectStrategy.WAITING;
        this.#interval = setInterval(()=>{
            this.#attempt++;
            if (this.#attempt > this.maxAttempts) {
                this.exit(TunnelReconnectStrategy.ABORTED);
            } else {
                this.status = TunnelReconnectStrategy.TRYING;
                this.connect(this);
            }
        }, 1000);
        return this;
    }
    exit(status = TunnelReconnectStrategy.COMPLETED) {
        this.status = status;
        if (this.#interval) {
            clearInterval(this.#interval);
            this.#interval = undefined;
        }
        return this;
    }
}
class EventSourceTunnelState {
    static instanceIndex = 0;
    static defaultInitialStatus = "inactive";
    esURL;
    esPingURL;
    #identity;
    #wrappedListeners = [];
    #eventSourceSupplier;
    #eventSource;
    #status;
    #statusErrorEvent;
    #statePresentation;
    #messageIdentitiesEncountered = {};
    constructor(tunnel, argsSupplier){
        this.esURL = `${tunnel.baseURL}/sse/tunnel`;
        this.esPingURL = `${tunnel.baseURL}/sse/ping`;
        const { args  } = governedArgs(argsSupplier, {
            defaultArgs: {
                eventSourceSupplier: ()=>new EventSource(this.esURL)
                ,
                statePresentation: ()=>tunnel.statePresentation
                ,
                identity: ()=>{
                    EventSourceTunnelState.instanceIndex++;
                    return `EventSourceTunnelState${EventSourceTunnelState.instanceIndex}`;
                },
                initialStatus: ()=>EventSourceTunnelState.defaultInitialStatus
            }
        });
        this.#eventSourceSupplier = args.eventSourceSupplier;
        this.#identity = args.identity();
        this.#status = args.initialStatus ? args.initialStatus() : EventSourceTunnelState.defaultInitialStatus;
        this.#statePresentation = args.statePresentation();
    }
    init(reconnector1 = undefined) {
        httpEndpointAvailableAction(this.esPingURL, (httpEAA)=>{
            this.#eventSource = this.#eventSourceSupplier();
            this.#eventSource.onopen = (event)=>{
                this.status = "active";
                if (reconnector1) reconnector1.exit();
            };
            this.#eventSource.onclose = (event)=>{
                this.status = "inactive";
                if (reconnector1) reconnector1.exit(TunnelReconnectStrategy.ABORTED);
            };
            this.#eventSource.onerror = (event)=>{
                this.#eventSource.close();
                this.#statusErrorEvent = event;
                this.status = "error";
                new TunnelReconnectStrategy((reconnector)=>{
                    this.init(reconnector);
                }, (reconnector)=>{
                    this.#statePresentation.update(this, {
                        enhanceBadgen: (suggested)=>{
                            suggested.status = reconnector.statusText;
                            return suggested;
                        }
                    });
                }).reconnect();
            };
            if (this.#wrappedListeners.length > 0) {
                this.#wrappedListeners.forEach((l)=>{
                    this.#eventSource.addEventListener(l.identity, l.wrappedCB);
                });
            }
        }, {
            onInvalidStatus: (event)=>{
                this.#status = "tunnel-unhealthy";
                this.#statePresentation.update(this, {
                    enhanceBadgen: (suggested)=>{
                        suggested.status = "unavailable";
                        suggested.elaborationText = `Ping URL ${this.esPingURL} is not available (click to hard-refresh)`;
                        suggested.elaborationHTML = `<a href="${this.esPingURL}">Ping URL</a> was not available.`;
                        suggested.actionable = ()=>{
                            httpHardRefreshURL();
                        };
                        return suggested;
                    }
                });
            }
        });
        return this;
    }
    get identity() {
        return this.#identity;
    }
    get status() {
        return this.#status;
    }
    set status(value) {
        this.#status = value;
        this.#statePresentation.update(this);
    }
    get statusErrorEvent() {
        return this.#statusErrorEvent;
    }
    get statePresentation() {
        return this.#statePresentation;
    }
    addEventSourceEventListener(identity, callback, options) {
        const wrappedCB = (event)=>{
            let encountered = this.#messageIdentitiesEncountered[identity];
            if (!encountered) {
                encountered = {
                    count: 0
                };
                this.#messageIdentitiesEncountered[identity] = encountered;
            }
            encountered.count++;
            const diagnose = options?.diagnose ?? false;
            if (diagnose) {
                console.info(`[TunnelState] message: ${identity}`, event, encountered);
            }
            callback(event);
        };
        this.#wrappedListeners.push({
            identity,
            wrappedCB,
            options
        });
        if (this.#eventSource) {
            this.#eventSource.addEventListener(identity, wrappedCB);
        }
        return this;
    }
}
class Tunnels {
    #esTunnels = {};
    constructor(argsSupplier){
        const { args  } = governedArgs(argsSupplier, {
            defaultArgs: {
                baseURL: "/tunnel",
                statePresentation: new TunnelStatePresentation()
            },
            hookableDomElemsAttrName: "tunnel-hook-args-supplier",
            hookableDomElems: [
                document.documentElement,
                document.head
            ]
        });
        this.baseURL = args.baseURL;
        this.statePresentation = args.statePresentation;
    }
    init() {
        return this;
    }
    registerEventSourceState(eventSourceTunnelStateArg) {
        const eventSourceTunnelState = typeof eventSourceTunnelStateArg === "function" ? eventSourceTunnelState(this) : eventSourceTunnelStateArg;
        eventSourceTunnelState.init();
        this.#esTunnels[eventSourceTunnelState.identity] = eventSourceTunnelState;
        return eventSourceTunnelState;
    }
}
export { LabeledBadge as LabeledBadge };
export { TunnelStatePresentation as TunnelStatePresentation };
export { TunnelReconnectStrategy as TunnelReconnectStrategy };
export { EventSourceTunnelState as EventSourceTunnelState };
export { Tunnels as Tunnels };
