<!DOCTYPE html>
<!-- follow guidelines in README.md, see FOUC section for why display:none is used-->
<html lang="en" style="display:none" data-universal-test-hook-fn="universalTestHookFn">

<head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="../path.actuate.css" />
    <script src="../path.actuate.js" type="module"></script>

    <link rel="stylesheet" href="https://unpkg.com/mocha/mocha.css" />
    <style>
        /* Prevent markdown flash of unstyled content (FOUC) by checking if we have a
           markdown class that doesn't have dataset.transformedFrom
           set to "markdown" yet, which means rendering hasn't occurred.
           Once rendering occurs, data-content-from="markdown"
           will be set properly and the display will be switched on.
           */
        .md:not([data-transformed-from="markdown"]) {
            display: none;
        }
    </style>
    <script>
        function universalTestHookFn(flexibleArgsResult) {
            flexibleArgsResult.args.hooked = "universalTestHookFn";
            return flexibleArgsResult;
        }
    </script>
</head>

<body>
    <main>
        <article>
            <header>
                <h1>Assurance Engineering (Unit Tests, QA)</h1>
            </header>

            <section class="card">
                <div id="mocha"></div>
            </section>

            <h3>Human Reviewable Test Results</h3>
            <section class="card">
                <details open class="card-body">
                    <summary>Rendered Markdown as HTML, with source from
                        <code>https://raw.githubusercontent.com/markdown-it/markdown-it/master/README.md</code>
                    </summary>
                    <div data-transformable="markdown"
                        data-transformable-src="https://raw.githubusercontent.com/mxstbr/markdown-test-file/master/TEST.md"
                        class="md"></div>
                </details>
                <details open class="card-body">
                    <summary>Rendered Markdown as HTML, with body in a <code>&lt;pre></code> tag</summary>
                    <!-- you can use any tag but we use a <pre> tag because browsers
                         won't usually escape or otherwise munge the content, making it
                         convenient to not have to escape text. To help prevent FOUC
                         check out the .md:not([data-transformed-from="markdown"]) style
                         -->
                    <pre data-transformable="markdown" class="md">
                        This is **markdown** _text_!
                    </pre>
                </details>
            </section>

            <section class="card">
                <div class="card-body">
                    <h5 class="card-title">TODO</h5>
                    <p>Remove tests from <code>index.html</code> into <code>xyz-assurance.js</code> or
                        <code>xyz-bdd.js</code>. Let's move the unit tests into <code>/assurance-cc</code> and
                        optionally allow pubctl.ts to control whether it's emitted with publication.
                    </p>
                    <p>Implement <a href="https://github.com/adamgruber/mochawesome"><code>mochawesome</code>
                            HTML/CSS Reporter for Mocha.js</a>.</p>
                </div>
            </section>
        </article>
    </main>

    <script src="https://unpkg.com/chai/chai.js"></script>
    <script src="https://unpkg.com/mocha/mocha.js"></script>

    <script type="module">
        mocha.setup('bdd');
        mocha.setup({ globals: ['webpackChunkmazer', 'sidebar', 'uidEvent', 'bootstrap', 'PerfectScrollbar', 'badgen'] });
        mocha.checkLeaks();
        import {
            jsTokenEvalResult,
            humanFriendlyPhrase,
            detectFileSysStyleRoute,
            flexibleArgs,
            governedArgs,
            EventEmitter,
            inspectUrlHttpHeaders,
            httpEndpointAvailableAction,
            transformMarkdownElems
        } from "./deps.auto.js";

        const assert = chai.assert;

        const syntheticScalarHook = "synthetic";
        const syntheticArrayHook = ["synthetic"];
        const syntheticObjectHook = { synthetic: "yes" };
        function syntheticFunctionHook() { }
        class SyntheticClassHook { }

        describe("universal-eval", () => {
            const igoreResult = () => { };
            const evalInThisScope = (js) => eval(js);

            it("jsTokenEvalResult (invalid)", () => {
                let badValues = 0;
                jsTokenEvalResult("alert('potential attack foiled!'))", eval, igoreResult, () => { badValues++ });
                jsTokenEvalResult("badFunction", eval, igoreResult, undefined, (error) => { badValues++ });
                assert(badValues == 2);
            });

            it("jsTokenEvalResult (class)", () => {
                const synthetic = jsTokenEvalResult("SyntheticClassHook", evalInThisScope);
                assert(synthetic === SyntheticClassHook);
            });

            it("jsTokenEvalResult (function)", () => {
                const synthetic = jsTokenEvalResult("syntheticFunctionHook", evalInThisScope);
                assert(synthetic === syntheticFunctionHook);
            });

            it("jsTokenEvalResult (values)", () => {
                let synthetic = jsTokenEvalResult("syntheticScalarHook", evalInThisScope);
                assert(synthetic === syntheticScalarHook);
                synthetic = jsTokenEvalResult("syntheticArrayHook", evalInThisScope);
                assert(synthetic === syntheticArrayHook);
                synthetic = jsTokenEvalResult("syntheticObjectHook", evalInThisScope);
                assert(synthetic === syntheticObjectHook);
            });
        });

        describe("universal-text", () => {
            it("humanFriendlyPhrase", () => {
                const inhumanText = "module-2_Component--_  1,=service_2";
                const result = humanFriendlyPhrase(inhumanText);
                assert(result == "Module 2 Component 1 Service 2");
            });
        });

        describe("universal-parser", () => {
            it("detectFileSysStyleRoute", () => {
                const complexPath =
                    "/some/long-ugly/file_sys_path/module-2_Component--_  1,=service_2.md";
                const result = detectFileSysStyleRoute(complexPath);
                assert(result.dir == "/some/long-ugly/file_sys_path");
                assert(result.base == "module-2_Component--_  1,=service_2.md");
                assert(result.name == "module-2_Component--_  1,=service_2");
                assert(result.modifiers.length == 0);
                assert(result.ext == ".md");
            });

            it("detectFileSysStyleRoute with modifiers", () => {
                const complexPath =
                    "/some/long-ugly/file_sys_path/module-2_Component--_  1,=service_2.mod1.mod2.md";
                const result = detectFileSysStyleRoute(complexPath);
                assert(result.root == "/");
                assert(result.dir == "/some/long-ugly/file_sys_path");
                assert(result.base == "module-2_Component--_  1,=service_2.mod1.mod2.md");
                assert(result.name == "module-2_Component--_  1,=service_2");
                assert(result.modifiers.length == 2);
                assert(result.ext == ".md");
            });
        });

        describe("universal-args", () => {
            it("flexibleArgs with no supplied args and rules object", () => {
                const result = flexibleArgs(undefined, { defaultArgs: { test: "value" } });
                assert(result);
                assert(typeof result === "object");
                assert(result.args.test == "value");
                assert(result.rules.defaultArgs.test == "value");
            });

            it("flexibleArgs with supplied args and rules function", () => {
                const result = flexibleArgs(
                    { another: "value" },
                    () => ({ defaultArgs: { fromDefaults: "value" } }));  // rules can be a function
                assert(result.args.fromDefaults == "value");
                assert(result.args.another == "value");
                assert(result.rules.defaultArgs.fromDefaults == "value");
            });

            it("flexibleArgs with supplied args function and rules function", () => {
                const result = flexibleArgs(
                    (defaults) => ({ ...defaults, another: "value" }), // if argsSupplier is a function, very important that ...defaults is spread
                    () => ({ defaultArgs: (rules, args, argsSupplier) => ({ test: "value" }) }));       // rules can be a function, and so can defaultArgs
                assert(result.args.test == "value");    // from defaultArgs
                assert(result.args.another == "value"); // from argsSupplier
            });

            it("flexibleArgs with supplied args object and hookable DOM function", () => {
                let hookable = undefined;
                let hook = undefined;
                const result = flexibleArgs({ test: "value" }, {
                    finalizeResult: (suggested) => {
                        // find the first hook available in the DOM
                        hookable = document.querySelector("[data-universal-test-hook-fn]");
                        if (hookable) {
                            // a hook name was found, see if it's a valid token and "execute" it
                            hook = jsTokenEvalResult(hookable.dataset.universalTestHookFn, (jsToken) => eval(jsToken));
                            if (hook) return hook(suggested);
                        }
                        // be sure to return the original otherwise failure is likely
                        return suggested;
                    },
                });
                assert(result);
                assert(hookable === document.documentElement);
                assert(hook === universalTestHookFn);
                assert(result.args.test == "value");
                assert(result.args.hooked == "universalTestHookFn");
            });

            it("governedArgs", () => {
                governedArgs({ test: "value" }, {
                    hookableDomElemsAttrName: "universal-test-hook-fn",
                    consumeArgs: ({ args }) => {
                        assert(args.test == "value");
                    }
                });
            });
        });

        describe("universal-event-emitter", () => {
            it("EventEmitter", () => {
                const ee = new EventEmitter();
                const testE1 = "testE1";
                const events = [];
                ee.on(testE1, (event) => {
                    events.push(event);
                });
                ee.emit(testE1, { first: true });
                ee.emit(testE1, { second: true });
                assert(events.length == 2);
                assert(events[0].first);
                assert(events[1].second);
            });
        });

        describe("universal-HTTP", () => {
            it("inspectUrlHttpHeaders", () => {
                inspectUrlHttpHeaders({
                    onHeaders: (headers) => {
                        assert(headers);
                        assert(typeof headers === "object");
                    },
                    onHeader: {
                        "content-length": (value, key, alias, url) => {
                            assert(key == "content-length");
                            assert(value > 0);
                            assert(alias == "contentLength");
                            assert(url);
                        },
                        "contentLength": (value, key, alias, url) => {
                            assert(key == "contentLength");
                            assert(value > 0);
                            assert(alias == "content-length");
                            assert(url);
                        },
                    }
                });
            });

            it("httpEndpointAvailableAction", () => {
                httpEndpointAvailableAction("/", (httpEAA) => {
                    // console.log("action", event);
                }, {
                    onInvalidStatus: (event) => {
                        // console.log("onInvalidStatus", event);
                    }
                });
            });
        });

        describe("universal-markdown-it", () => {
            it("transformMarkdownElems", async () => {
                const event = (event) => {
                    // The parent is assumed to be a <details> tag, which was
                    // was open by default (if details is not open, rendering
                    // will fail) so now we want to close it.
                    event.detail.mdHtmlElem.parentElement.open = false;
                    transformed++;
                };
                let transformed = 0;
                document.addEventListener("transformed-markdown", event);
                await transformMarkdownElems();
                assert(transformed == 2);
                document.removeEventListener('transformed-markdown', event)
            });
        });

        mocha.run();
    </script>
</body>

</html>