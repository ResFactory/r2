<!DOCTYPE html>
<!-- follow guidelines in README.md, see FOUC section for why display:none is used-->
<html lang="en" style="display:none">

<head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="../path.actuate.css" />
    <script src="../path.actuate.js" type="module"></script>
    <script src="https://unpkg.com/ag-grid-community/dist/ag-grid-community.min.js"></script>
    <style>
        /* Remove default bullets */
        ul,
        #routes-tree {
            list-style-type: none;
        }

        /* Remove margins and padding from the parent ul */
        #routes-tree {
            margin: 0;
            padding: 0;
        }

        /* Style the expander/arrow */
        .expander {
            cursor: pointer;
            user-select: none;
            /* Prevent text selection */
        }

        /* Create the expander/arrow with a unicode, and style it */
        .expander::before {
            content: "\25B6";
            color: #999999;
            display: inline-block;
            margin-right: 6px;
        }

        /* Rotate the expander/arrow icon when clicked on (using JavaScript) */
        .expander-down::before {
            transform: rotate(90deg);
        }

        /* Hide the nested list */
        .nested {
            display: none;
        }

        /* Style the expander/arrow */
        .leaf {
            cursor: pointer;
        }

        /* Create the expander/arrow with a unicode, and style it */
        .leaf::before {
            content: "\25B6";
            /* use same character to get right indent level */
            color: white;
            /* hide it using background color */
            display: inline-block;
            margin-right: 6px;
        }

        /* Show the nested list when the user clicks on the expander/arrow (with JavaScript) */
        .active {
            display: block;
        }
    </style>
</head>

<body>
    <main>
        <article>
            <header>
                <h1>Routes</h1>
            </header>

            <div class="row">
                <div class="col-sm-6">
                    <div class="card">
                        <div class="card-body">
                            <h5 class="card-title">Navigable Routes</h5>
                            <p><code>publication.state.resourcesTree.items</code></p>
                            <ul id="routes-tree">
                            </ul>
                        </div>
                    </div>
                </div>
                <div class="col-sm-6">
                    <div class="card">
                        <div class="card-body">
                            <h5 class="card-title" id="route-node-properties-title">Properties</h5>
                            <div id="route-node-properties">
                                Click on a route on the left to see the route's properties here.
                            </div>
                            <div id="route-node-properties-footer">
                                <details>
                                    <summary>as JSON</summary>
                                    <div id="route-node-properties-json">

                                    </div>
                                </details>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <section class="card">
                <div class="card-body">
                    <h5 class="card-title"><code>publication.state.resourcesTree</code>
                    </h5>
                    <p>Resource Factory <code>publication.ts</code> captures all originated resource routes into
                        <code>PublicationState</code>'s <code>resourcesTree</code> field of type <a
                            href="/workspace/editor-redirect/factory/governance/route.ts"><code>rfGovn.RouteTree</code></a>.
                    </p>
                    <p>What follows is a JSON representation of the entire tree. The <code>items</code> field in the
                        <code>resourcesTree</code> is what is inspectable above.
                    </p>
                    <div id="routes-json" clss="text-muted"></div>
                </div>
            </section>

            <h2>TODO</h2>
            <section class="card">
                <section class="card-body">
                    <pre data-transformable="markdown">
                        ### Route and file system path-specific configuration

                        - See [The Ultimate Guide to Hugo Sections](https://cloudcannon.com/blog/the-ultimate-guide-to-hugo-sections/)
                        to eliminate `_index.md` and replace with `path.ts` or `path.js.ts` or similar.
                        - Use [astring](https://www.skypack.dev/view/astring) JavaScript code generator
                        by building ESTree-compliant ASTs for JavaScript-based routes and other
                        artifacts. For example, we can create a `routes.js` which would be similar to
                        `routes.json` except in JavaScript instead of JSON. By including JavaScript
                        instead of JSON we can have easier use within HTML files and be able to catch
                        reference errors when structures change.
                        - Similar to functionality in NEFS Sparx which generated type-safe code for
                            custom sites.
                        - Also, we could consider generating TypeScript by adding some typing on top
                            of the generated JS. Similar to how
                            [GSD](https://github.com/gov-suite/governed-structured-data) operates; or,
                            we could just use GSD out of the box?
                        - Implement `.Resource Factory.ts` type-safe _profiles_ which will include all
                        extensions and supply configurations such as `layout` and other rules. Instead
                        of forcing all rules in a common configuration, allow `.Resource Factory.ts`
                        at any route to override any configuration value by merging properties with
                        ancestors. This will be referred to as the Resource Factory _Route Profile_ or
                        _Resource Profile_.

                        ### Routes and Trees

                        - Introduce namespaces into routes so they can indicate where they fit into
                        multiple systems (e.g. more than one statically generate site or multiple
                        projects that can be built without each others' knowledge).
                        - [Nomia](https://github.com/scarf-sh/nomia/) is an interesting project for
                            universal resource namespaces and might be worth integrating.
                        - Incorporate https://deno.land/x/urlcat for type-safe URLs in Routes
                        - Implement route computation using
                        [path-to-regexp.compile()](https://github.com/pillarjs/path-to-regexp/blob/master/src/index.ts#L252)
                        - Check out https://web.dev/urlpattern/ for additional ideas
                        - Check out https://www.skypack.dev/view/regexparam which is much smaller
                            could potentially be incorporated directly without becoming a source
                            dependency.
                        - Read Astro's
                        [File\-based routing, inspired by
                        Next\.js](https://astro.build/blog/astro-019#file-based-routing-inspired-by-nextjs)
                        article to understand how routing is defined by Next.js SvelteKit to allow
                        similar patterns to be passed into originators and resource constructors.
                        - Consider generating UUIDv4 identities for each resource's body content so that
                        body content can be "fingerprinted" for caching and testing for changes
                        without using a revision control system. This will allow resources to be
                        portable across publications.
                        - Consider generating UUIDv4 identities for each route tree node so that the
                        same route from any partial sites will generate the same ID. This will allow
                        routes to know when they have been "moved".
                        - Implement aliasing so that parsed routes can indicate that they "belong" to a
                        different parent than their physical location. These are almost like parent
                        aliases.
                        - Consider allowing setting `parents` so that the same resource could insert
                            itself into multiple parents. Instead of being an alias, the same resource
                            could be in two routes.
                        - This capability might allow better partial routes which would allow a child
                            to insert itself to a parent route, if it existed, and ignore if it did not
                            exist.
                        - Allow directories to become routes without necessarily tying it to a resource
                        - Should directories themselves become originators (resource factories)?
                        - Implement [related content](https://gohugo.io/content-management/related/)
                        similar to the way Hugo and other SSGs work. In our case, we can allow dynamic
                        relationships with Frontmatter (untyped) or Models (type-safe).
                        ```
                    </pre>
                </section>
            </section>
        </article>
    </main>

    <!-- consider replacing renderjson.js with https://github.com/mohsen1/json-formatter-js for <a>/URL formatting -->
    <script src="https://cdn.rawgit.com/caldwell/renderjson/master/renderjson.js"></script>
    <script type="module">
        import { reflect } from "../deps.auto.js";

        const suppressProps = ["children", "ancestors", "fileSysPathParts"];
        const inspectReflected = (inspect, propsGridElem) => {
            const reflected = reflect(inspect, undefined, {
                enhanceObject: (o, ancestors) => {
                    const fileSysPath = o.properties.find(p => p.key == "fileSysPath");
                    if (fileSysPath) {
                        fileSysPath.type = "fsPath";
                    }
                    return o;
                },
                objPropsFilter: (key, obj) => {
                    if (suppressProps.find(k => k == key)) return false;
                    return true;
                }
            });
            const columnDefs = [
                { field: "property" },
                { field: "type" },
                {
                    field: "value",
                    //cellRenderer: "valueCellRenderer",
                }
            ];
            const rowData = [];
            for (const p of reflected.properties.sort((a, b) => a.key == b.key ? 0 : (a.key > b.key ? 1 : -1))) {
                rowData.push({ property: p.key, type: p.type, value: p.value });
            }
            const gridOptions = {
                columnDefs: columnDefs,
                rowData,
                domLayout: 'autoHeight',
                onGridReady: (event) => event.columnApi.autoSizeAllColumns(),
                components: {
                    // see https://www.ag-grid.com/javascript-grid/components/
                    valueCellRenderer: (params) => params.value,
                },
            };
            new agGrid.Grid(propsGridElem, gridOptions);
        }

        document.addEventListener('DOMContentLoaded', function () {
            fetch("/publication/inspect/routes.json").then(resp => resp.json()).then(routes => {
                renderjson.set_icons('▶︎ ', '▼ ');
                renderjson.set_show_to_level(1);
                renderjson.set_replacer(undefined);
                document.getElementById("routes-json").prepend(renderjson(routes));

                const routeNodeProps = document.getElementById("route-node-properties");
                const routeNodePropsJSON = document.getElementById("route-node-properties-json");
                const routeNodePropsTitle = document.getElementById("route-node-properties-title");
                const handleNodes = (parentUL, items) => {
                    items.sort((a, b) => (a.label > b.label) ? 1 : -1).forEach(i => {
                        const li = document.createElement("li");
                        if (i.children && i.children.length > 0) {
                            const expander = document.createElement("span");
                            expander.className = "expander";
                            expander.innerHTML = i.label;
                            expander.routeNode = i;
                            li.appendChild(expander);
                            const childUL = document.createElement("ul");
                            childUL.className = "nested";
                            li.appendChild(childUL);
                            handleNodes(childUL, i.children);

                            expander.addEventListener("click", function () {
                                expander.parentElement.querySelector(".nested").classList.toggle("active");
                                expander.classList.toggle("expander-down");
                                routeNodePropsTitle.innerHTML = `${i.qualifiedPath} "${i.label}" (${i.children.length} children)`;
                                routeNodeProps.innerHTML = "";
                                inspectReflected(i, routeNodeProps);
                                routeNodePropsJSON.innerHTML = "";
                                routeNodePropsJSON.prepend(renderjson(i));
                            });
                        } else {
                            li.className = "leaf";
                            li.innerHTML = i.label;
                            li.addEventListener("click", function () {
                                routeNodePropsTitle.innerHTML = `${i.qualifiedPath} "${i.label}"`;
                                routeNodeProps.innerHTML = "";
                                inspectReflected(i, routeNodeProps);
                                routeNodePropsJSON.innerHTML = "";
                                routeNodePropsJSON.prepend(renderjson(i));
                            });
                        }
                        parentUL.appendChild(li);
                    });
                };
                handleNodes(document.querySelector("#routes-tree"), routes.items);
            })
        });
    </script>
</body>

</html>