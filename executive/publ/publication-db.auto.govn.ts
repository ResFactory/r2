// Generated by publication-db.sqla.ts. DO NOT EDIT.
// Template: RF_HOME/lib/sql/render/template/emittable-typescript.ts

// deno-lint-ignore no-explicit-any
type Any = any; // to ease lint warnings

export type CamelCase<S extends string> = S extends
  `${infer P1}_${infer P2}${infer P3}`
  ? `${Lowercase<P1>}${Uppercase<P2>}${CamelCase<P3>}`
  : Lowercase<S>;

export type TableToObject<T> = {
  [K in keyof T as CamelCase<string & K>]: T[K] extends Date ? T[K]
    : // deno-lint-ignore ban-types
    (T[K] extends object ? TableToObject<T[K]> : T[K]);
};

export type RequireOnlyOne<T, Keys extends keyof T = keyof T> =
  & Pick<T, Exclude<keyof T, Keys>>
  & {
    [K in Keys]-?:
      & Required<Pick<T, K>>
      & Partial<Record<Exclude<Keys, K>, undefined>>;
  }[Keys];

export interface SqlTextEmitOptions<Context> {
  readonly quotedLiteral: (value: unknown) => [value: unknown, quoted: string];
}

export interface SqlTextSupplier<
  Context,
  EmitOptions extends SqlTextEmitOptions<Context>,
> {
  readonly SQL: (ctx?: Context, options?: EmitOptions) => string;
}

export type InsertStmtReturning<
  ReturnableRecord,
  ReturnableColumnName extends keyof ReturnableRecord = keyof ReturnableRecord,
  ReturnableColumnExpr extends string = string,
> =
  | "*"
  | "primary-keys"
  | RequireOnlyOne<{
    readonly columns?: ReturnableColumnName[];
    readonly exprs?: ReturnableColumnExpr[];
  }>;

export interface InsertStmtPreparer<
  Context,
  TableName,
  PrimaryKeyColName extends string,
  InsertableRecord,
  ReturnableRecord,
  EmitOptions extends SqlTextEmitOptions<Context>,
  InsertableColumnName extends keyof InsertableRecord = keyof InsertableRecord,
  ReturnableColumnName extends keyof ReturnableRecord = keyof ReturnableRecord,
  ReturnableColumnExpr extends (keyof ReturnableRecord | string) =
    (keyof ReturnableRecord | string),
> {
  (ir: InsertableRecord, options?: {
    readonly emitColumn?: (
      columnName: keyof InsertableRecord,
      record: InsertableRecord,
      tableName: TableName,
      eo?: EmitOptions,
      ctx?: Context,
    ) =>
      | [columNameSqlText: string, value: unknown, valueSqlText: string]
      | undefined;
    readonly where?:
      | SqlTextSupplier<Context, EmitOptions>
      | ((
        ctx?: Context,
        eo?: EmitOptions,
      ) => SqlTextSupplier<Context, EmitOptions>);
    readonly onConflict?:
      | SqlTextSupplier<Context, EmitOptions>
      | ((
        ctx?: Context,
        eo?: EmitOptions,
      ) => SqlTextSupplier<Context, EmitOptions>);
    readonly returning?:
      | InsertStmtReturning<ReturnableRecord>
      | ((
        ctx?: Context,
        eo?: EmitOptions,
      ) => InsertStmtReturning<ReturnableRecord>);
    readonly transformSQL?: (
      suggested: string,
      tableName: TableName,
      record: InsertableRecord,
      names: InsertableColumnName[],
      values: [value: unknown, sqlText: string][],
      eo?: EmitOptions,
      ctx?: Context,
    ) => string;
  }): SqlTextSupplier<Context, EmitOptions>;
}

export function typicalInsertStmtPreparer<
  Context,
  TableName,
  PrimaryKeyColName extends string,
  InsertableRecord,
  ReturnableRecord,
  EmitOptions extends SqlTextEmitOptions<Context>,
  InsertableColumnName extends keyof InsertableRecord = keyof InsertableRecord,
  ReturnableColumnExpr extends (keyof ReturnableRecord | string) =
    (keyof ReturnableRecord | string),
>(
  tableName: TableName,
  candidateColumns: InsertableColumnName[],
  pkColumns?: PrimaryKeyColName[],
): InsertStmtPreparer<
  Context,
  TableName,
  PrimaryKeyColName,
  InsertableRecord,
  ReturnableRecord,
  EmitOptions
> {
  return (ir, pisOptions) => {
    return {
      SQL: (ctx, eo) => {
        const { emitColumn, returning: returningArg, where, onConflict } =
          pisOptions ?? {};
        const names: InsertableColumnName[] = [];
        const values: [value: unknown, valueSqlText: string][] = [];
        candidateColumns.forEach((c) => {
          let ec: [
            columNameSqlText: string,
            value: unknown,
            valueSqlText: string,
          ] | undefined;
          if (emitColumn) {
            ec = emitColumn(c, ir, tableName, eo, ctx);
          } else {
            const { quotedLiteral = typicalQuotedLiteral } = eo ?? {};
            const qValue = quotedLiteral((ir as Any)[c]);
            ec = [c as string, ...qValue];
          }
          if (ec) {
            const [columNameSqlText, value, valueSqlText] = ec;
            names.push(columNameSqlText as InsertableColumnName);
            values.push([value, valueSqlText]);
          }
        });
        const sqlText = (
          ss?:
            | SqlTextSupplier<Context, EmitOptions>
            | ((
              ctx?: Context,
              eo?: EmitOptions,
            ) => SqlTextSupplier<Context, EmitOptions>),
        ) => {
          if (!ss) return "";
          const SQL = typeof ss == "function"
            ? ss(ctx, eo).SQL(ctx, eo)
            : ss.SQL(ctx, eo);
          return ` ${SQL}`;
        };
        const returning = returningArg
          ? (typeof returningArg === "function"
            ? returningArg(ctx, eo)
            : returningArg)
          : undefined;
        let returningSQL = "";
        if (typeof returning === "string") {
          switch (returning) {
            case "*":
              returningSQL = ` RETURNING *`;
              break;
            case "primary-keys":
              returningSQL = ` RETURNING ${pkColumns!.join(", ")}`;
              break;
          }
        } else if (typeof returning === "object") {
          if (returning.columns) {
            returningSQL = ` RETURNING ${returning!.columns!.join(", ")}`;
          } else {
            returningSQL = ` RETURNING ${returning!.exprs!.join(", ")}`;
          }
        }
        // deno-fmt-ignore
        const SQL = `INSERT INTO ${tableName} (${names.join(", ")}) VALUES (${values.map((value) => value[1]).join(", ")
          })${sqlText(where)}${sqlText(onConflict)}${returningSQL}`;
        return pisOptions?.transformSQL
          ? pisOptions?.transformSQL(
            SQL,
            tableName,
            ir,
            names,
            values,
            eo,
            ctx,
          )
          : SQL;
      },
    };
  };
}

export interface GovernedTable<TableName> {
  readonly tableName: TableName;
}

export interface TableDataTransferSuppliers<
  TableName,
  TableRecord,
  TsObject,
  InsertableRecord,
  InsertableObject,
> extends GovernedTable<TableName> {
  readonly fromTable: (t: TableRecord) => TsObject;
  readonly toTable: (o: TsObject) => TableRecord;
  readonly insertable: (o: InsertableObject) => InsertableRecord;
}

export interface TableDmlSuppliers<
  Context,
  TableName,
  PrimaryKeyColName extends string,
  InsertableRecord,
  ReturnableRecord,
  EmitOptions extends SqlTextEmitOptions<Context>,
> extends GovernedTable<TableName> {
  readonly prepareInsertStmt: InsertStmtPreparer<
    Context,
    TableName,
    PrimaryKeyColName,
    InsertableRecord,
    ReturnableRecord,
    EmitOptions
  >;
}

export type UnknownJSON = string;

export interface mutable_publ_host {
  publ_host_id: number; // INTEGER, NOT NULL, primary key
  host: string; // TEXT, NOT NULL
  host_identity?: UnknownJSON; // JSON
  mutation_count: number; // INTEGER, NOT NULL
  created_at?: Date; // DATETIME, default: CURRENT_TIMESTAMP
}

export const publHostTableName = "publ_host" as const;
export const publHostPrimaryKeyColNames = ["publ_host_id"];
export type PublHostPrimaryKeyColName = "publ_host_id";
export type publ_host = Readonly<mutable_publ_host>;
export type MutablePublHost = TableToObject<mutable_publ_host>;
export type PublHost = Readonly<MutablePublHost>;
export type publ_host_insertable =
  & Omit<publ_host, "publ_host_id" | "created_at">
  & Partial<Pick<publ_host, "created_at">>;
export type mutable_publ_host_insertable =
  & Omit<mutable_publ_host, "publ_host_id" | "created_at">
  & Partial<Pick<mutable_publ_host, "created_at">>;
export type PublHostInsertable =
  & Omit<PublHost, "publHostId" | "createdAt">
  & Partial<Pick<PublHost, "createdAt">>;
export type publ_host_updateable =
  & Omit<publ_host, "publ_host_id" | "created_at">
  & Partial<Pick<publ_host, "created_at">>;
export type PublHostUpdatable =
  & Omit<PublHost, "publHostId" | "createdAt">
  & Partial<Pick<PublHost, "createdAt">>;

export const publHostDT: TableDataTransferSuppliers<
  typeof publHostTableName,
  publ_host,
  PublHost,
  publ_host_insertable,
  PublHostInsertable
> = {
  tableName: publHostTableName,
  fromTable: (record) => ({
    publHostId: record.publ_host_id,
    host: record.host,
    hostIdentity: record.host_identity,
    mutationCount: record.mutation_count,
    createdAt: record.created_at,
  }),
  toTable: (o) => ({
    publ_host_id: o.publHostId,
    host: o.host,
    host_identity: o.hostIdentity,
    mutation_count: o.mutationCount,
    created_at: o.createdAt,
  }),
  insertable: (o) => {
    const insertable: mutable_publ_host_insertable = {
      host: o.host,
      host_identity: o.hostIdentity,
      mutation_count: o.mutationCount,
      created_at: o.createdAt,
    };
    if (typeof insertable.created_at === "undefined") {
      delete insertable.created_at; // allow RDBMS to supply the defaultValue CURRENT_TIMESTAMP
    }
    return insertable;
  },
};

export function publHostDML<
  Context = unknown,
  EmitOptions extends SqlTextEmitOptions<Context> = SqlTextEmitOptions<Context>,
>(): TableDmlSuppliers<
  Context,
  typeof publHostTableName,
  PublHostPrimaryKeyColName,
  publ_host_insertable,
  publ_host,
  EmitOptions
> {
  return {
    tableName: publHostTableName,
    prepareInsertStmt: typicalInsertStmtPreparer(publHostTableName, [
      "host",
      "host_identity",
      "mutation_count",
      "created_at",
    ], publHostPrimaryKeyColNames),
  };
}

export interface mutable_publ_build_event {
  publ_build_event_id: number; // INTEGER, NOT NULL, primary key
  publ_host_id: number; // INTEGER, NOT NULL, FK: publ_host.publ_host_id
  iteration_index: number; // INTEGER, NOT NULL
  build_initiated_at: Date; // DATETIME, NOT NULL
  build_completed_at: Date; // DATETIME, NOT NULL
  build_duration_ms: number; // INTEGER, NOT NULL
  resources_originated_count: number; // INTEGER, NOT NULL
  resources_persisted_count: number; // INTEGER, NOT NULL
  resources_memoized_count: number; // INTEGER, NOT NULL
  created_at?: Date; // DATETIME, default: CURRENT_TIMESTAMP
}

export const publBuildEventTableName = "publ_build_event" as const;
export const publBuildEventPrimaryKeyColNames = ["publ_build_event_id"];
export type PublBuildEventPrimaryKeyColName = "publ_build_event_id";
export type publ_build_event = Readonly<mutable_publ_build_event>;
export type MutablePublBuildEvent = TableToObject<mutable_publ_build_event>;
export type PublBuildEvent = Readonly<MutablePublBuildEvent>;
export type publ_build_event_insertable =
  & Omit<publ_build_event, "publ_build_event_id" | "created_at">
  & Partial<Pick<publ_build_event, "created_at">>;
export type mutable_publ_build_event_insertable =
  & Omit<mutable_publ_build_event, "publ_build_event_id" | "created_at">
  & Partial<Pick<mutable_publ_build_event, "created_at">>;
export type PublBuildEventInsertable =
  & Omit<PublBuildEvent, "publBuildEventId" | "createdAt">
  & Partial<Pick<PublBuildEvent, "createdAt">>;
export type publ_build_event_updateable =
  & Omit<publ_build_event, "publ_build_event_id" | "created_at">
  & Partial<Pick<publ_build_event, "created_at">>;
export type PublBuildEventUpdatable =
  & Omit<PublBuildEvent, "publBuildEventId" | "createdAt">
  & Partial<Pick<PublBuildEvent, "createdAt">>;

export const publBuildEventDT: TableDataTransferSuppliers<
  typeof publBuildEventTableName,
  publ_build_event,
  PublBuildEvent,
  publ_build_event_insertable,
  PublBuildEventInsertable
> = {
  tableName: publBuildEventTableName,
  fromTable: (record) => ({
    publBuildEventId: record.publ_build_event_id,
    publHostId: record.publ_host_id,
    iterationIndex: record.iteration_index,
    buildInitiatedAt: record.build_initiated_at,
    buildCompletedAt: record.build_completed_at,
    buildDurationMs: record.build_duration_ms,
    resourcesOriginatedCount: record.resources_originated_count,
    resourcesPersistedCount: record.resources_persisted_count,
    resourcesMemoizedCount: record.resources_memoized_count,
    createdAt: record.created_at,
  }),
  toTable: (o) => ({
    publ_build_event_id: o.publBuildEventId,
    publ_host_id: o.publHostId,
    iteration_index: o.iterationIndex,
    build_initiated_at: o.buildInitiatedAt,
    build_completed_at: o.buildCompletedAt,
    build_duration_ms: o.buildDurationMs,
    resources_originated_count: o.resourcesOriginatedCount,
    resources_persisted_count: o.resourcesPersistedCount,
    resources_memoized_count: o.resourcesMemoizedCount,
    created_at: o.createdAt,
  }),
  insertable: (o) => {
    const insertable: mutable_publ_build_event_insertable = {
      publ_host_id: o.publHostId,
      iteration_index: o.iterationIndex,
      build_initiated_at: o.buildInitiatedAt,
      build_completed_at: o.buildCompletedAt,
      build_duration_ms: o.buildDurationMs,
      resources_originated_count: o.resourcesOriginatedCount,
      resources_persisted_count: o.resourcesPersistedCount,
      resources_memoized_count: o.resourcesMemoizedCount,
      created_at: o.createdAt,
    };
    if (typeof insertable.created_at === "undefined") {
      delete insertable.created_at; // allow RDBMS to supply the defaultValue CURRENT_TIMESTAMP
    }
    return insertable;
  },
};

export function publBuildEventDML<
  Context = unknown,
  EmitOptions extends SqlTextEmitOptions<Context> = SqlTextEmitOptions<Context>,
>(): TableDmlSuppliers<
  Context,
  typeof publBuildEventTableName,
  PublBuildEventPrimaryKeyColName,
  publ_build_event_insertable,
  publ_build_event,
  EmitOptions
> {
  return {
    tableName: publBuildEventTableName,
    prepareInsertStmt: typicalInsertStmtPreparer(publBuildEventTableName, [
      "publ_host_id",
      "iteration_index",
      "build_initiated_at",
      "build_completed_at",
      "build_duration_ms",
      "resources_originated_count",
      "resources_persisted_count",
      "resources_memoized_count",
      "created_at",
    ], publBuildEventPrimaryKeyColNames),
  };
}

export interface mutable_publ_server_service {
  publ_server_service_id: number; // INTEGER, NOT NULL, primary key
  service_started_at: Date; // DATETIME, NOT NULL
  listen_host: string; // TEXT, NOT NULL
  listen_port: number; // INTEGER, NOT NULL
  publish_url: string; // TEXT, NOT NULL
  publ_build_event_id: number; // INTEGER, NOT NULL, FK: publ_build_event.publ_build_event_id
  created_at?: Date; // DATETIME, default: CURRENT_TIMESTAMP
}

export const publServerServiceTableName = "publ_server_service" as const;
export const publServerServicePrimaryKeyColNames = ["publ_server_service_id"];
export type PublServerServicePrimaryKeyColName = "publ_server_service_id";
export type publ_server_service = Readonly<mutable_publ_server_service>;
export type MutablePublServerService = TableToObject<
  mutable_publ_server_service
>;
export type PublServerService = Readonly<MutablePublServerService>;
export type publ_server_service_insertable =
  & Omit<publ_server_service, "publ_server_service_id" | "created_at">
  & Partial<Pick<publ_server_service, "created_at">>;
export type mutable_publ_server_service_insertable =
  & Omit<mutable_publ_server_service, "publ_server_service_id" | "created_at">
  & Partial<Pick<mutable_publ_server_service, "created_at">>;
export type PublServerServiceInsertable =
  & Omit<PublServerService, "publServerServiceId" | "createdAt">
  & Partial<Pick<PublServerService, "createdAt">>;
export type publ_server_service_updateable =
  & Omit<publ_server_service, "publ_server_service_id" | "created_at">
  & Partial<Pick<publ_server_service, "created_at">>;
export type PublServerServiceUpdatable =
  & Omit<PublServerService, "publServerServiceId" | "createdAt">
  & Partial<Pick<PublServerService, "createdAt">>;

export const publServerServiceDT: TableDataTransferSuppliers<
  typeof publServerServiceTableName,
  publ_server_service,
  PublServerService,
  publ_server_service_insertable,
  PublServerServiceInsertable
> = {
  tableName: publServerServiceTableName,
  fromTable: (record) => ({
    publServerServiceId: record.publ_server_service_id,
    serviceStartedAt: record.service_started_at,
    listenHost: record.listen_host,
    listenPort: record.listen_port,
    publishUrl: record.publish_url,
    publBuildEventId: record.publ_build_event_id,
    createdAt: record.created_at,
  }),
  toTable: (o) => ({
    publ_server_service_id: o.publServerServiceId,
    service_started_at: o.serviceStartedAt,
    listen_host: o.listenHost,
    listen_port: o.listenPort,
    publish_url: o.publishUrl,
    publ_build_event_id: o.publBuildEventId,
    created_at: o.createdAt,
  }),
  insertable: (o) => {
    const insertable: mutable_publ_server_service_insertable = {
      service_started_at: o.serviceStartedAt,
      listen_host: o.listenHost,
      listen_port: o.listenPort,
      publish_url: o.publishUrl,
      publ_build_event_id: o.publBuildEventId,
      created_at: o.createdAt,
    };
    if (typeof insertable.created_at === "undefined") {
      delete insertable.created_at; // allow RDBMS to supply the defaultValue CURRENT_TIMESTAMP
    }
    return insertable;
  },
};

export function publServerServiceDML<
  Context = unknown,
  EmitOptions extends SqlTextEmitOptions<Context> = SqlTextEmitOptions<Context>,
>(): TableDmlSuppliers<
  Context,
  typeof publServerServiceTableName,
  PublServerServicePrimaryKeyColName,
  publ_server_service_insertable,
  publ_server_service,
  EmitOptions
> {
  return {
    tableName: publServerServiceTableName,
    prepareInsertStmt: typicalInsertStmtPreparer(publServerServiceTableName, [
      "service_started_at",
      "listen_host",
      "listen_port",
      "publish_url",
      "publ_build_event_id",
      "created_at",
    ], publServerServicePrimaryKeyColNames),
  };
}

export interface mutable_publ_server_static_access_log {
  publ_server_static_access_log_id: number; // INTEGER, NOT NULL, primary key
  status: number; // INTEGER, NOT NULL
  asset_nature: string; // TEXT, NOT NULL
  location_href: string; // TEXT, NOT NULL
  filesys_target_path: string; // TEXT, NOT NULL
  filesys_target_symlink?: string; // TEXT
  publ_server_service_id: number; // INTEGER, NOT NULL, FK: publ_server_service.publ_server_service_id
  created_at?: Date; // DATETIME, default: CURRENT_TIMESTAMP
}

export const publServerStaticAccessLogTableName =
  "publ_server_static_access_log" as const;
export const publServerStaticAccessLogPrimaryKeyColNames = [
  "publ_server_static_access_log_id",
];
export type PublServerStaticAccessLogPrimaryKeyColName =
  "publ_server_static_access_log_id";
export type publ_server_static_access_log = Readonly<
  mutable_publ_server_static_access_log
>;
export type MutablePublServerStaticAccessLog = TableToObject<
  mutable_publ_server_static_access_log
>;
export type PublServerStaticAccessLog = Readonly<
  MutablePublServerStaticAccessLog
>;
export type publ_server_static_access_log_insertable =
  & Omit<
    publ_server_static_access_log,
    "publ_server_static_access_log_id" | "created_at"
  >
  & Partial<Pick<publ_server_static_access_log, "created_at">>;
export type mutable_publ_server_static_access_log_insertable =
  & Omit<
    mutable_publ_server_static_access_log,
    "publ_server_static_access_log_id" | "created_at"
  >
  & Partial<Pick<mutable_publ_server_static_access_log, "created_at">>;
export type PublServerStaticAccessLogInsertable =
  & Omit<PublServerStaticAccessLog, "publServerStaticAccessLogId" | "createdAt">
  & Partial<Pick<PublServerStaticAccessLog, "createdAt">>;
export type publ_server_static_access_log_updateable =
  & Omit<
    publ_server_static_access_log,
    "publ_server_static_access_log_id" | "created_at"
  >
  & Partial<Pick<publ_server_static_access_log, "created_at">>;
export type PublServerStaticAccessLogUpdatable =
  & Omit<PublServerStaticAccessLog, "publServerStaticAccessLogId" | "createdAt">
  & Partial<Pick<PublServerStaticAccessLog, "createdAt">>;

export const publServerStaticAccessLogDT: TableDataTransferSuppliers<
  typeof publServerStaticAccessLogTableName,
  publ_server_static_access_log,
  PublServerStaticAccessLog,
  publ_server_static_access_log_insertable,
  PublServerStaticAccessLogInsertable
> = {
  tableName: publServerStaticAccessLogTableName,
  fromTable: (record) => ({
    publServerStaticAccessLogId: record.publ_server_static_access_log_id,
    status: record.status,
    assetNature: record.asset_nature,
    locationHref: record.location_href,
    filesysTargetPath: record.filesys_target_path,
    filesysTargetSymlink: record.filesys_target_symlink,
    publServerServiceId: record.publ_server_service_id,
    createdAt: record.created_at,
  }),
  toTable: (o) => ({
    publ_server_static_access_log_id: o.publServerStaticAccessLogId,
    status: o.status,
    asset_nature: o.assetNature,
    location_href: o.locationHref,
    filesys_target_path: o.filesysTargetPath,
    filesys_target_symlink: o.filesysTargetSymlink,
    publ_server_service_id: o.publServerServiceId,
    created_at: o.createdAt,
  }),
  insertable: (o) => {
    const insertable: mutable_publ_server_static_access_log_insertable = {
      status: o.status,
      asset_nature: o.assetNature,
      location_href: o.locationHref,
      filesys_target_path: o.filesysTargetPath,
      filesys_target_symlink: o.filesysTargetSymlink,
      publ_server_service_id: o.publServerServiceId,
      created_at: o.createdAt,
    };
    if (typeof insertable.created_at === "undefined") {
      delete insertable.created_at; // allow RDBMS to supply the defaultValue CURRENT_TIMESTAMP
    }
    return insertable;
  },
};

export function publServerStaticAccessLogDML<
  Context = unknown,
  EmitOptions extends SqlTextEmitOptions<Context> = SqlTextEmitOptions<Context>,
>(): TableDmlSuppliers<
  Context,
  typeof publServerStaticAccessLogTableName,
  PublServerStaticAccessLogPrimaryKeyColName,
  publ_server_static_access_log_insertable,
  publ_server_static_access_log,
  EmitOptions
> {
  return {
    tableName: publServerStaticAccessLogTableName,
    prepareInsertStmt: typicalInsertStmtPreparer(
      publServerStaticAccessLogTableName,
      [
        "status",
        "asset_nature",
        "location_href",
        "filesys_target_path",
        "filesys_target_symlink",
        "publ_server_service_id",
        "created_at",
      ],
      publServerStaticAccessLogPrimaryKeyColNames,
    ),
  };
}

export interface mutable_publ_server_error_log {
  publ_server_error_log_id: number; // INTEGER, NOT NULL, primary key
  location_href: string; // TEXT, NOT NULL
  error_summary: string; // TEXT, NOT NULL
  error_elaboration?: UnknownJSON; // JSON
  publ_server_service_id: number; // INTEGER, NOT NULL, FK: publ_server_service.publ_server_service_id
  created_at?: Date; // DATETIME, default: CURRENT_TIMESTAMP
}

export const publServerErrorLogTableName = "publ_server_error_log" as const;
export const publServerErrorLogPrimaryKeyColNames = [
  "publ_server_error_log_id",
];
export type PublServerErrorLogPrimaryKeyColName = "publ_server_error_log_id";
export type publ_server_error_log = Readonly<mutable_publ_server_error_log>;
export type MutablePublServerErrorLog = TableToObject<
  mutable_publ_server_error_log
>;
export type PublServerErrorLog = Readonly<MutablePublServerErrorLog>;
export type publ_server_error_log_insertable =
  & Omit<publ_server_error_log, "publ_server_error_log_id" | "created_at">
  & Partial<Pick<publ_server_error_log, "created_at">>;
export type mutable_publ_server_error_log_insertable =
  & Omit<
    mutable_publ_server_error_log,
    "publ_server_error_log_id" | "created_at"
  >
  & Partial<Pick<mutable_publ_server_error_log, "created_at">>;
export type PublServerErrorLogInsertable =
  & Omit<PublServerErrorLog, "publServerErrorLogId" | "createdAt">
  & Partial<Pick<PublServerErrorLog, "createdAt">>;
export type publ_server_error_log_updateable =
  & Omit<publ_server_error_log, "publ_server_error_log_id" | "created_at">
  & Partial<Pick<publ_server_error_log, "created_at">>;
export type PublServerErrorLogUpdatable =
  & Omit<PublServerErrorLog, "publServerErrorLogId" | "createdAt">
  & Partial<Pick<PublServerErrorLog, "createdAt">>;

export const publServerErrorLogDT: TableDataTransferSuppliers<
  typeof publServerErrorLogTableName,
  publ_server_error_log,
  PublServerErrorLog,
  publ_server_error_log_insertable,
  PublServerErrorLogInsertable
> = {
  tableName: publServerErrorLogTableName,
  fromTable: (record) => ({
    publServerErrorLogId: record.publ_server_error_log_id,
    locationHref: record.location_href,
    errorSummary: record.error_summary,
    errorElaboration: record.error_elaboration,
    publServerServiceId: record.publ_server_service_id,
    createdAt: record.created_at,
  }),
  toTable: (o) => ({
    publ_server_error_log_id: o.publServerErrorLogId,
    location_href: o.locationHref,
    error_summary: o.errorSummary,
    error_elaboration: o.errorElaboration,
    publ_server_service_id: o.publServerServiceId,
    created_at: o.createdAt,
  }),
  insertable: (o) => {
    const insertable: mutable_publ_server_error_log_insertable = {
      location_href: o.locationHref,
      error_summary: o.errorSummary,
      error_elaboration: o.errorElaboration,
      publ_server_service_id: o.publServerServiceId,
      created_at: o.createdAt,
    };
    if (typeof insertable.created_at === "undefined") {
      delete insertable.created_at; // allow RDBMS to supply the defaultValue CURRENT_TIMESTAMP
    }
    return insertable;
  },
};

export function publServerErrorLogDML<
  Context = unknown,
  EmitOptions extends SqlTextEmitOptions<Context> = SqlTextEmitOptions<Context>,
>(): TableDmlSuppliers<
  Context,
  typeof publServerErrorLogTableName,
  PublServerErrorLogPrimaryKeyColName,
  publ_server_error_log_insertable,
  publ_server_error_log,
  EmitOptions
> {
  return {
    tableName: publServerErrorLogTableName,
    prepareInsertStmt: typicalInsertStmtPreparer(publServerErrorLogTableName, [
      "location_href",
      "error_summary",
      "error_elaboration",
      "publ_server_service_id",
      "created_at",
    ], publServerErrorLogPrimaryKeyColNames),
  };
}

export const typicalQuotedLiteral = (
  value: unknown,
): [value: unknown, quoted: string] => {
  if (typeof value === "undefined") return [value, "NULL"];
  if (typeof value === "string") {
    return [value, `'${value.replaceAll("'", "''")}'`];
  }
  return [value, String(value)];
};

export function typicalSqlEmitOptions<Context>(
  inherit?: SqlTextEmitOptions<Context>,
): SqlTextEmitOptions<Context> {
  return {
    quotedLiteral: typicalQuotedLiteral,
    ...inherit,
  };
}
