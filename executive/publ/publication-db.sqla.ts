import { path } from "../../core/deps.ts";
import * as SQLa from "../../lib/sql/render/mod.ts";

// deno-lint-ignore no-explicit-any
type Any = any;

export interface PubDbSqlAssemblerContext {
  readonly tdfs: SQLa.TableDefnFactoriesSupplier<PubDbSqlAssemblerContext>;
  readonly vdf: SQLa.ViewDefnFactory<PubDbSqlAssemblerContext>;
}

export function publDbSchemaGovn(ctx: PubDbSqlAssemblerContext) {
  const { tdfs } = ctx;

  const publHost = SQLa.typicalStaticTableDefn(ctx, "publ_host", [
    "host",
    "host_identity",
    "mutation_count",
  ], tdfs)(
    (defineColumns, { columnsFactory: cf, decoratorsFactory: df }) => {
      defineColumns(
        cf.text("host"),
        cf.JSON("host_identity", { isNullable: true }),
        cf.integer("mutation_count"),
      );
      df.unique("host");
    },
  );

  const publBuildEvent = SQLa.typicalStaticTableDefn(ctx, "publ_build_event", [
    "publ_host_id",
    "iteration_index",
    "build_initiated_at",
    "build_completed_at",
    "build_duration_ms",
    "resources_originated_count",
    "resources_persisted_count",
    "resources_memoized_count",
  ], tdfs)(
    (defineColumns, { columnsFactory: cf }) => {
      defineColumns(
        publHost.primaryKeyColDefn.foreignKeyTableColDefn(),
        cf.integer("iteration_index"),
        cf.dateTime("build_initiated_at"),
        cf.dateTime("build_completed_at"),
        cf.integer("build_duration_ms"),
        cf.integer("resources_originated_count"),
        cf.integer("resources_persisted_count"),
        cf.integer("resources_memoized_count"),
      );
    },
  );

  const publServerService = SQLa.typicalStaticTableDefn(
    ctx,
    "publ_server_service",
    [
      "service_started_at",
      "listen_host",
      "listen_port",
      "publish_url",
      "publ_build_event_id",
    ],
    tdfs,
  )(
    (defineColumns, { columnsFactory: cf }) => {
      defineColumns(
        cf.dateTime("service_started_at"),
        cf.text("listen_host"),
        cf.integer("listen_port"),
        cf.text("publish_url"),
        publBuildEvent.primaryKeyColDefn.foreignKeyTableColDefn(),
      );
    },
  );

  // -- TODO: add indexes to improve query performance
  const publServerStaticAccessLog = SQLa.typicalStaticTableDefn(
    ctx,
    "publ_server_static_access_log",
    [
      "status",
      "asset_nature",
      "location_href",
      "filesys_target_path",
      "filesys_target_symlink",
      "publ_server_service_id",
    ],
    tdfs,
  )(
    (defineColumns, { columnsFactory: cf }) => {
      defineColumns(
        cf.integer("status"),
        cf.text("asset_nature"),
        cf.text("location_href"),
        cf.text("filesys_target_path"),
        cf.text("filesys_target_symlink", { isNullable: true }),
        publServerService.primaryKeyColDefn.foreignKeyTableColDefn(),
      );
    },
  );

  // -- TODO: add indexes to improve query performance
  const publServerErrorLog = SQLa.typicalStaticTableDefn(
    ctx,
    "publ_server_error_log",
    [
      "location_href",
      "error_summary",
      "error_elaboration",
      "publ_server_service_id",
    ],
    tdfs,
  )(
    (defineColumns, { columnsFactory: cf }) => {
      defineColumns(
        cf.text("location_href"),
        cf.text("error_summary"),
        cf.JSON("error_elaboration", { isNullable: true }),
        publServerService.primaryKeyColDefn.foreignKeyTableColDefn(),
      );
    },
  );

  return {
    publHost,
    publBuildEvent,
    publServerService,
    publServerStaticAccessLog,
    publServerErrorLog,
  };
}

export function publDbSQL() {
  const ctx: PubDbSqlAssemblerContext = {
    tdfs: SQLa.sqliteTableDefnFactories(),
    vdf: SQLa.typicalSqlViewDefnFactory(),
  };
  const schema = publDbSchemaGovn(ctx);
  const tablesDeclared = new Set<
    SQLa.TableDefinition<PubDbSqlAssemblerContext, Any, Any, Any>
  >();

  // deno-fmt-ignore
  const catalog = (sts: SQLa.SqlTextSupplier<PubDbSqlAssemblerContext, Any>) => {
    if (SQLa.isTableDefinition<PubDbSqlAssemblerContext, Any, Any, SQLa.SqlTextEmitOptions<PubDbSqlAssemblerContext>>(sts)) {
      tablesDeclared.add(sts);
    }
  }

  // deno-fmt-ignore
  const DDL = SQLa.SQL<PubDbSqlAssemblerContext>(SQLa.typicalSqlTextSupplierOptions({
    prepareEvents: (spEE) => {
      spEE.on("sqlEmitted", (_, sts) => catalog(sts));
      return spEE;
    }
  }))`
      -- Generated by ${path.basename(import.meta.url)}. DO NOT EDIT.
      -- Governance:
      -- * use 3rd normal form for tables
      -- * use views to wrap business logic
      -- * when denormalizing is required, use views (don't denormalize tables)
      -- * each table name MUST be singular (not plural) noun
      -- * each table MUST have a \`table_name\`_id primary key (typicalTableDefn will do this automatically)
      -- * each table MUST have \`created_at DATETIME DEFAULT CURRENT_TIMESTAMP NOT NULL\` column (typicalTableDefn will do this automatically)
      -- * if table's rows are mutable, it MUST have a \`updated_at DATETIME\` column (not having an updated_at means it's immutable)
      -- * if table's rows are deleteable, it MUST have a \`deleted_at DATETIME\` column for soft deletes (not having an deleted_at means it's immutable)

      -- TODO: create a govn_* set of tables that would contain business logic, assurance, presentation, and other details
      --       govn_entity would be a table that stores table meta data (descriptions, immutability, presentation, migration instructions, etc.)
      --       govn_entity_property would be a table that stores table column meta data (descriptions, immutability, presentation, migration instructions, etc.)
      --       govn_entity_relationship would be a table that stores entity/property relationships (1:N, 1:M, etc.) for literate programming documentation, etc.
      --       govn_entity_activity would be a table that stores governance history and activity data in JSON format for documentation, migration status, etc.

      ${SQLa.typicalSqlTextLintSummary}

      ${schema.publHost.tableDefn}

      ${schema.publBuildEvent.tableDefn}

      ${schema.publServerService.tableDefn}

      ${schema.publServerStaticAccessLog.tableDefn}

      ${schema.publServerErrorLog.tableDefn}`;

  const emitOptions = SQLa.typicalSqlTextEmitOptions<
    PubDbSqlAssemblerContext
  >();
  const SQL = DDL.SQL(ctx, emitOptions);
  const tsGovn = SQLa.tablesGovnTypescript(tablesDeclared, ctx, emitOptions, {
    origin: path.basename(path.fromFileUrl(import.meta.url)),
  });
  return { catalog, SQL, tsGovn };
}

export async function persistPublDbSqlAssets(
  options?: { readonly destPath: string; readonly baseNamePrefix: string },
) {
  const thisFile = path.parse(path.fromFileUrl(import.meta.url));
  const {
    destPath = thisFile.dir,
    baseNamePrefix = thisFile.name.replace(/\.[^/.]+$/, ""),
  } = options ?? {};
  const { SQL, tsGovn } = publDbSQL();
  const sqlDestPath = path.join(destPath, `${baseNamePrefix}.auto.sql`);
  const tsGovnDestPath = path.join(destPath, `${baseNamePrefix}.auto.govn.ts`);
  await Deno.writeTextFile(sqlDestPath, SQL);
  await Deno.writeTextFile(tsGovnDestPath, tsGovn);
  await Deno.run({ cmd: [Deno.execPath(), "fmt", tsGovnDestPath] })
    .status();
  return {
    sqlDestPath,
    tsGovnDestPath,
    SQL,
    tsGovn,
  };
}

if (import.meta.main) {
  await persistPublDbSqlAssets();
}
