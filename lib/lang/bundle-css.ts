import { events } from "./deps.ts";

export interface StylesheetSupplier {
  readonly srcRootSpecifier: string;
}

export interface BundledStylesheetEvent extends StylesheetSupplier {
  readonly transformed: string;
}

export interface BundledStylesheetSupplier {
  readonly bundledCSS: () => string;
}

export interface NotBundledTypescriptEvent<ReasonCtx>
  extends StylesheetSupplier {
  readonly reason:
    | "business-rule"
    | "src-not-found"
    | "diagnosable-issue"
    | "undiagnosable-error"
    | string;
  readonly reasonCtx?: ReasonCtx;
}

export class TransformStylesheetEventEmitter extends events.EventEmitter<{
  bundledToCSS(
    evt: BundledStylesheetEvent & BundledStylesheetSupplier,
  ): Promise<void>;
  persistedToCSS(
    jsAbsPath: string,
    evt: BundledStylesheetEvent & BundledStylesheetSupplier,
  ): Promise<void>;
  notBundledToCSS(
    evt: NotBundledTypescriptEvent<unknown> & {
      readonly er?: Deno.EmitResult;
      readonly error?: Error;
    },
  ): Promise<void>;
  diagnosableBundleIssue(evt: BundledStylesheetEvent): Promise<void>;
  undiagnosableBundleError(ts: StylesheetSupplier, e: Error): Promise<void>;
}> {}

export interface TransformStylesheetOptions {
  readonly ee?: TransformStylesheetEventEmitter;
  readonly shouldBundle?: (
    rootSpecifier: string,
    dfi: Deno.FileInfo,
  ) => Promise<true | [string, unknown]>;
  readonly onBundledToCSS: (
    evt: BundledStylesheetEvent & BundledStylesheetSupplier,
  ) => Promise<void>;
}

export async function transformTypescriptToJS(
  ts: StylesheetSupplier,
  options?: TransformStylesheetOptions,
) {
  const { srcRootSpecifier } = ts;
  try {
    const stat = await Deno.lstat(ts.srcRootSpecifier);
    if (options?.shouldBundle) {
      const should = await options.shouldBundle(srcRootSpecifier, stat);
      if (should != true) {
        const [reason, reasonCtx] = should;
        await options?.ee?.emit("notBundledToCSS", {
          reason: reason || "business-rule",
          reasonCtx,
          ...ts,
        });
        return;
      }
    }
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      await options?.ee?.emit("notBundledToCSS", {
        reason: "src-not-found",
        ...ts,
        error: err,
      });
      return;
    }
    throw err;
  }

  try {
    const module = await import(srcRootSpecifier);
    if (module && module.default) {
      let transformed: string | undefined;
      switch (typeof module.default) {
        case "function":
          transformed = module.default();
          break;
        case "string":
          transformed = module.default;
          break;
      }
      if (transformed) {
        const event = {
          ...ts,
          transformed,
          bundledCSS: () => transformed!,
        };
        options?.onBundledToCSS?.(event);
        await options?.ee?.emit("bundledToCSS", event);
      } else {
        await options?.ee?.emit("diagnosableBundleIssue", {
          ...ts,
          transformed:
            `no default text or function returning text available in ${srcRootSpecifier}`,
        });
        await options?.ee?.emit("notBundledToCSS", {
          ...ts,
          reason: "diagnosable-issue",
          reasonCtx:
            `no default text or function returning text available in ${srcRootSpecifier}`,
        });
      }
    }
  } catch (error) {
    await options?.ee?.emit("undiagnosableBundleError", ts, error);
    await options?.ee?.emit("notBundledToCSS", {
      reason: "undiagnosable-error",
      ...ts,
      error,
    });
  }
}

export interface cssTsTwinNamingStrategy {
  (jsAbsPath: string): string;
}

export const typicalCssTwinTsNamingStrategy: cssTsTwinNamingStrategy = (
  jsAbsPath,
) => {
  // if the output file looks like xyz.auto.js rename it to xyz.js so that
  // the Typescript "twin" doesnt have the word auto in there
  return jsAbsPath.replace(".auto.", ".");
};

export async function cssHasTsTwin(
  jsAbsPath: string,
  namingStrategy = typicalCssTwinTsNamingStrategy,
): Promise<false | [twinPath: string, twinStat: Deno.FileInfo]> {
  const twinPath = `${namingStrategy(jsAbsPath)}.ts`;
  try {
    const twinStat = await Deno.lstat(twinPath);
    return [twinPath, twinStat];
  } catch (error) {
    // if the *.js doesn't exist we want to build it
    if (error instanceof Deno.errors.NotFound) {
      return false;
    }
    throw error;
  }
}

export async function bundleStylesheetFromTsTwin(
  jsAbsPath: string,
  namingStrategy = typicalCssTwinTsNamingStrategy,
  ee?: TransformStylesheetEventEmitter,
) {
  await transformTypescriptToJS({
    srcRootSpecifier: `${namingStrategy(jsAbsPath)}.ts`,
  }, {
    ee,
    onBundledToCSS: async (event) => {
      const bundle =
        `/* Code generated by bundle-css.ts. DO NOT EDIT. */\n${event.bundledCSS()}`;
      await Deno.writeTextFile(jsAbsPath, bundle);
      await ee?.emit("persistedToCSS", jsAbsPath, event);
    },
  });
}

export async function bundleStylesheetFromTsTwinIfNewer(
  jsAbsPath: string,
  namingStrategy = typicalCssTwinTsNamingStrategy,
  ee?: TransformStylesheetEventEmitter,
) {
  await transformTypescriptToJS({
    srcRootSpecifier: `${namingStrategy(jsAbsPath)}.ts`,
  }, {
    ee,
    shouldBundle: async (src, srcStat) => {
      let destStat: Deno.FileInfo;
      try {
        destStat = await Deno.lstat(jsAbsPath);
      } catch (error) {
        // if the *.js doesn't exist we want to build it
        if (error instanceof Deno.errors.NotFound) {
          return true;
        }
        return ["should-bundle-exception", {
          src,
          srcStat,
          dest: jsAbsPath,
          error,
        }];
      }

      if (srcStat.mtime && destStat.mtime) {
        if (srcStat.mtime.getTime() < destStat.mtime.getTime()) {
          return ["dest-is-newer-than-src", {
            src,
            srcStat,
            dest: jsAbsPath,
            destStat,
          }];
        }
      }
      return true;
    },
    onBundledToCSS: async (event) => {
      const bundle =
        `/* Code generated by bundle-css.ts based on timestamp. DO NOT EDIT. */\n${event.bundledCSS()}`;
      await Deno.writeTextFile(jsAbsPath, bundle);
      await ee?.emit("persistedToCSS", jsAbsPath, event);
    },
  });
}
