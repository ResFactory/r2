class EventEmitter{_events_=new Map;on(event,listener){return this._events_.has(event)||this._events_.set(event,new Set),this._events_.get(event).add(listener),this}once(event,listener){const l=listener;return l.__once__=!0,this.on(event,l)}off(event,listener){if(null==event&&listener)throw new Error("Why is there a listenerÂ defined here?");if(null!=event||listener){if(event&&!listener)this._events_.delete(event);else if(event&&listener&&this._events_.has(event)){const _=this._events_.get(event);_.delete(listener),0===_.size&&this._events_.delete(event)}}else this._events_.clear();return this}emitSync(event,...args){if(!this._events_.has(event))return this;const _=this._events_.get(event);for(let[,listener]of _.entries()){const r=listener(...args);r instanceof Promise&&r.catch(console.error),listener.__once__&&(delete listener.__once__,_.delete(listener))}return 0===_.size&&this._events_.delete(event),this}async emit(event,...args){if(!this._events_.has(event))return this;const _=this._events_.get(event);for(let[,listener]of _.entries())try{await listener(...args),listener.__once__&&(delete listener.__once__,_.delete(listener))}catch(error){console.error(error)}return 0===_.size&&this._events_.delete(event),this}queue(event,...args){return(async()=>await this.emit(event,...args))().catch(console.error),this}pull(event,timeout){return new Promise((async(resolve,reject)=>{let timeoutId,listener=(...args)=>{null!==timeoutId&&clearTimeout(timeoutId),resolve(args)};timeoutId="number"!=typeof timeout?null:setTimeout((()=>(this.off(event,listener),reject(new Error("Timed out!"))))),this.once(event,listener)}))}}export{EventEmitter};function humanFriendlyBytes(bytes,si=!1,dp=1){const thresh=si?1e3:1024;if(Math.abs(bytes)<thresh)return bytes+" B";const units=si?["kB","MB","GB","TB","PB","EB","ZB","YB"]:["KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"];let u=-1;const r=10**dp;do{bytes/=thresh,++u}while(Math.round(Math.abs(bytes)*r)/r>=thresh&&u<units.length-1);return bytes.toFixed(dp)+" "+units[u]}function humanFriendlyPhrase(text){return text.replace(/[^a-zA-Z0-9 ]/g," ").replace(/\s\s+/g," ").replace(/(^\w{1})|(\s+\w{1})/g,(letter=>letter.toUpperCase()))}export{humanFriendlyBytes};export{humanFriendlyPhrase};function minWhitespaceIndent(text){const match=text.match(/^[ \t]*(?=\S)/gm);return match?match.reduce(((r,a)=>Math.min(r,a.length)),1/0):0}function unindentWhitespace(text,removeInitialNewLine=!0){const indent=minWhitespaceIndent(text),regex=new RegExp(`^[ \\t]{${indent}}`,"gm"),result=text.replace(regex,"");return removeInitialNewLine?result.replace(/^\n/,""):result}function singleLineTrim(text){return text.replace(/(\r\n|\n|\r)/gm,"").replace(/\s+(?=(?:[^\'"]*[\'"][^\'"]*[\'"])*[^\'"]*$)/g," ").trim()}export{minWhitespaceIndent};export{unindentWhitespace};export{singleLineTrim};const jsTokenEvalRE=/^[a-zA-Z0-9_]+$/;function jsTokenEvalResult(identity,discover,isTokenValid,onInvalidToken,onFailedDiscovery){let result;if(identity.match(jsTokenEvalRE))try{if(Array.isArray(discover)){for(const te of discover)if(result=te(identity),result)break}else result=discover(identity);result&&isTokenValid&&(result=isTokenValid(result,identity))}catch(error){result=onFailedDiscovery?.(error,identity)}else result=onInvalidToken?.(identity);return result}const jsTokenEvalResults={};function cacheableJsTokenEvalResult(name1,discover=eval,onInvalidToken,onFailedDiscovery){return name1 in jsTokenEvalResults?jsTokenEvalResults[name1]:jsTokenEvalResult(name1,discover,((value,name)=>(jsTokenEvalResults[name]=value,value)),onInvalidToken,onFailedDiscovery)}function flexibleArgs(argsSupplier,rulesSupplier){const rules=rulesSupplier?"function"==typeof rulesSupplier?rulesSupplier(argsSupplier):rulesSupplier:void 0,defaultArgsSupplier=rules?.defaultArgs??{},defaultArgs="function"==typeof defaultArgsSupplier?defaultArgsSupplier(argsSupplier,rules):defaultArgsSupplier;let args="function"==typeof argsSupplier?argsSupplier(defaultArgs,rules):argsSupplier?{...defaultArgs,...argsSupplier}:defaultArgs;rules?.argsGuard&&(rules?.argsGuard.guard(args)||(args=rules.argsGuard.onFailure(args,rules)));let result={args:args,rules:rules};return rules?.finalizeResult&&(result=rules.finalizeResult(result)),result}function governedArgs(argsSupplier,rulesSupplier){return flexibleArgs(argsSupplier,rulesSupplier)}export{jsTokenEvalResult};export{cacheableJsTokenEvalResult};export{flexibleArgs};export{governedArgs};const posixPathRE=/^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;function detectFileSysStyleRoute(text){const components=posixPathRE.exec(text)?.slice(1);if(!components||5!==components.length)return;const modifiers=[],parsedPath={root:components[1],dir:components[0].slice(0,-1),base:components[2],ext:components[4],name:components[3],modifiers:modifiers},modifierIndex=parsedPath.name.lastIndexOf(".");if(modifierIndex>0){let ppn=parsedPath.name,modifier=ppn.substring(modifierIndex);for(;modifier&&modifier.length>0;){modifiers.push(modifier),ppn=ppn.substring(0,ppn.length-modifier.length);const modifierIndex=ppn.lastIndexOf(".");modifier=modifierIndex>0?ppn.substring(modifierIndex):void 0}parsedPath.name=ppn}return parsedPath}export{detectFileSysStyleRoute};function httpEndpointAvailableAction(url1,action,state){const http1=state?.prepareXMLHttpRequest?state.prepareXMLHttpRequest(url1,state):((url,state)=>{const http=new XMLHttpRequest;return http.open("HEAD",url,!0),http.setRequestHeader("Content-Type","text/plain"),http})(url1);http1.onreadystatechange=function(xhrEvent){4==http1.readyState&&(200==http1.status?action({request:http1,url:url1,xhrEvent:xhrEvent,state:state}):state?.onInvalidStatus&&state.onInvalidStatus({request:http1,url:url1,xhrEvent:xhrEvent,state:state}))};try{http1.send(null)}catch(error){state?.onError&&state?.onInvalidStatus&&state.onInvalidStatus({request:http1,url:url1,xhrEvent:xhrEvent,state:state,error:error})}}export{httpEndpointAvailableAction};class LabeledBadge{remoteBaseURL;useBadgenLib;importModule;#initialized=!1;#isBadgenLibLoaded=!1;autoHTML;constructor(argsSupplier){const{args:args}=governedArgs(argsSupplier,{defaultArgs:{remoteBaseURL:"https://badgen.net/badge",importModule:(lib,actuate)=>import(lib).then(actuate),useBadgenLib:!0}});this.remoteBaseURL=args.remoteBaseURL,this.useBadgenLib=args.useBadgenLib,this.importModule=args.importModule}badgenArgs(args){const badgenArgs={status:args.status||"status",...args};return args?.enhanceBadgen?args.enhanceBadgen(badgenArgs):badgenArgs}badgenRemoteURL(badgenArgs){const badge=this.badgenArgs(badgenArgs);return`${this.remoteBaseURL}/${badge.label}/${badge.status}/${badge.color}`}decorateHTML(badgenArgs,html){return badgenArgs.elaborationText&&(html=`<span title="${badgenArgs.elaborationText}">${html}</span>`),badgenArgs.actionable&&(html=`<a onclick="${badgenArgs.actionable}">${html}</a>`),html}badgenRemoteImageHTML(badgenArgs){return this.decorateHTML(badgenArgs,`<img src="${this.badgenRemoteURL(badgenArgs)}">`)}init(){return this.#initialized||(this.autoHTML=badgenArgs=>this.badgenRemoteImageHTML(badgenArgs),this.useBadgenLib&&this.importModule("https://unpkg.com/badgen",(()=>{this.autoHTML=badgenArgs=>this.decorateHTML(badgenArgs,badgen(this.badgenArgs(badgenArgs))),this.#isBadgenLibLoaded=!0})),this.#initialized=!0),this}get isBadgenLibLoaded(){return this.#isBadgenLibLoaded}}class TunnelStatePresentation{static defaultInitialStatus="inactive";summaryBadgeDomID;elaborationHtmlDomID;constructor(argsSupplier){const{args:args}=governedArgs(argsSupplier,{defaultArgs:{summaryBadgeDomID:"rf-universal-tunnel-state-summary-badge",elaborationHtmlDomID:"rf-universal-tunnel-state-elaboration",initialStatus:TunnelStatePresentation.defaultInitialStatus,labeledBadge:(new LabeledBadge).init(),defaultLabel:"Tunnel"}});this.summaryBadgeDomID=args.summaryBadgeDomID,this.elaborationHtmlDomID=args.elaborationHtmlDomID,this.labeledBadge=args.labeledBadge,this.defaultLabel=args.defaultLabel}badgenArgs(state,options){const status=state.status,label=options?.label??this.defaultLabel,color=options?.color??("inactive"==status?"red":"active"==status?"green":"orange"),icon=options?.icon;return this.labeledBadge.badgenArgs({label:label,labelColor:"555",status:status,color:color,style:"classic",icon:icon,iconWidth:13,scale:1,...options})}update(state,options){const tspElem=document.getElementById(this.summaryBadgeDomID);tspElem?tspElem.innerHTML=this.labeledBadge.autoHTML(this.badgenArgs(state,options)):console.warn(`Tunnel state could not be updated: DOM element id='${this.summaryBadgeDomID}' was not found.`)}display(state=!0){this.summaryBadgeElement&&(this.summaryBadgeElement.style.display=state?"block":"none")}get summaryBadgeElement(){return document.getElementById(this.summaryBadgeDomID)}get elaborationHtmlElement(){return document.getElementById(this.elaborationHtmlDomID)}get isStatisticsPresentationPossible(){return this.labeledBadge.isBadgenLibLoaded}}class TunnelReconnectStrategy{static UNKNOWN=0;static WAITING=1;static TRYING=2;static COMPLETED=3;static ABORTED=4;connect;report;maxAttempts;#attempt;#interval;#status=TunnelReconnectStrategy.UNKNOWN;constructor(connect,report,maxAttempts=15){this.connect=connect,this.report=report,this.maxAttempts=maxAttempts,this.#attempt=0}get attempt(){return this.#attempt}get status(){return this.#status}set status(value){this.#status=value,this.report(this)}get statusText(){switch(this.#status){case TunnelReconnectStrategy.UNKNOWN:return"unknown";case TunnelReconnectStrategy.WAITING:return"waiting";case TunnelReconnectStrategy.TRYING:return`reconnecting ${this.#attempt}/${this.maxAttempts}`;case TunnelReconnectStrategy.COMPLETED:return"reconnected";case TunnelReconnectStrategy.ABORTED:return"aborted"}return"?"}reconnect(){return this.status=TunnelReconnectStrategy.WAITING,this.#interval=setInterval((()=>{this.#attempt++,this.#attempt>this.maxAttempts?this.exit(TunnelReconnectStrategy.ABORTED):(this.status=TunnelReconnectStrategy.TRYING,this.connect(this))}),1e3),this}exit(status=TunnelReconnectStrategy.COMPLETED){return this.status=status,this.#interval&&(clearInterval(this.#interval),this.#interval=void 0),this}}class EventSourceTunnelState{static instanceIndex=0;static defaultInitialStatus="inactive";esURL;esPingURL;#identity;#wrappedListeners=[];#eventSourceSupplier;#eventSource;#status;#statusErrorEvent;#statePresentation;#messageIdentitiesEncountered={};constructor(tunnel,argsSupplier){this.esURL=`${tunnel.baseURL}/sse/tunnel`,this.esPingURL=`${tunnel.baseURL}/sse/ping`;const{args:args}=governedArgs(argsSupplier,{defaultArgs:{eventSourceSupplier:()=>new EventSource(this.esURL),statePresentation:()=>tunnel.statePresentation,identity:()=>(EventSourceTunnelState.instanceIndex++,`EventSourceTunnelState${EventSourceTunnelState.instanceIndex}`),initialStatus:()=>EventSourceTunnelState.defaultInitialStatus}});this.#eventSourceSupplier=args.eventSourceSupplier,this.#identity=args.identity(),this.#status=args.initialStatus?args.initialStatus():EventSourceTunnelState.defaultInitialStatus,this.#statePresentation=args.statePresentation()}init(reconnector1){return httpEndpointAvailableAction(this.esPingURL,(httpEAA=>{this.#eventSource=this.#eventSourceSupplier(),this.#eventSource.onopen=event=>{this.status="active",reconnector1&&reconnector1.exit()},this.#eventSource.onclose=event=>{this.status="inactive",reconnector1&&reconnector1.exit(TunnelReconnectStrategy.ABORTED)},this.#eventSource.onerror=event=>{this.#eventSource.close(),this.#statusErrorEvent=event,this.status="error",new TunnelReconnectStrategy((reconnector=>{this.init(reconnector)}),(reconnector=>{this.#statePresentation.update(this,{enhanceBadgen:suggested=>(suggested.status=reconnector.statusText,suggested)})})).reconnect()},this.#wrappedListeners.length>0&&this.#wrappedListeners.forEach((l=>{this.#eventSource.addEventListener(l.identity,l.wrappedCB)}))}),{onInvalidStatus:event=>{this.#status="tunnel-unhealthy",this.#statePresentation.update(this,{enhanceBadgen:suggested=>(suggested.status="unavailable",suggested.elaborationText=`Ping URL ${this.esPingURL} is not available (click to hard-refresh)`,suggested.elaborationHTML=`<a href="${this.esPingURL}">Ping URL</a> was not available.`,suggested.actionable=()=>{httpHardRefreshURL()},suggested)})}}),this}get identity(){return this.#identity}get status(){return this.#status}set status(value){this.#status=value,this.#statePresentation.update(this)}get statusErrorEvent(){return this.#statusErrorEvent}get statePresentation(){return this.#statePresentation}addEventSourceEventListener(identity,callback,options){const wrappedCB=event=>{let encountered=this.#messageIdentitiesEncountered[identity];encountered||(encountered={count:0},this.#messageIdentitiesEncountered[identity]=encountered),encountered.count++;(options?.diagnose??!1)&&console.info(`[TunnelState] message: ${identity}`,event,encountered),callback(event)};return this.#wrappedListeners.push({identity:identity,wrappedCB:wrappedCB,options:options}),this.#eventSource&&this.#eventSource.addEventListener(identity,wrappedCB),this}}class Tunnels{#esTunnels={};constructor(argsSupplier){const{args:args}=governedArgs(argsSupplier,{defaultArgs:{baseURL:"/tunnel",statePresentation:new TunnelStatePresentation},hookableDomElemsAttrName:"tunnel-hook-args-supplier",hookableDomElems:[document.documentElement,document.head]});this.baseURL=args.baseURL,this.statePresentation=args.statePresentation}init(){return this}registerEventSourceState(eventSourceTunnelStateArg){const eventSourceTunnelState="function"==typeof eventSourceTunnelStateArg?eventSourceTunnelState(this):eventSourceTunnelStateArg;return eventSourceTunnelState.init(),this.#esTunnels[eventSourceTunnelState.identity]=eventSourceTunnelState,eventSourceTunnelState}}export{LabeledBadge};export{TunnelStatePresentation};export{TunnelReconnectStrategy};export{EventSourceTunnelState};export{Tunnels};class UserAgentBus{#clientReqMessageBaseURL;#config;#registry=[];#identifiables={};constructor(argsSupplier){if(this.#config=flexibleArgs(argsSupplier,{defaultArgs:{hookableDomElemsAttrName:"user-interactions-args-supplier",hookableDomElems:[document.documentElement,document.head],domElemHookName:(element,potentialName=element.dataset.tunnelUi)=>"auto"==potentialName||"yes"==potentialName?`tuiHook_${element.id||`${element.tagName}_${this.registry.length}`}`:potentialName,discoverDomElemHook(element,discover=eval){const hookName=this.domElemHookName(element),hookFactory=jsTokenEvalResult(hookName,discover,((value,name)=>value),(name=>{console.log(`[UserAgentBus.discoverDomElemHook] '${name}' is not a token for current scope (${element.tagName} ${element.id})`,element)}),((error,name)=>{console.log(`[UserAgentBus.discoverDomElemHook] token discovery '${name}' generated error in current scope (${element.tagName} ${element.id}): ${error}`,error,element)}));if(hookFactory){const hook=hookFactory(element,hookName,this);return hook.operationsEE.emit("constructed",{element:element,hookName:hookName,hookFactory:hookFactory,uab:this}),this.register(hook)}},prepareClientReqMessage:(hook,message)=>({nature:"UserAgentBus.message",tuiHookIdentity:hook.identity,...message}),determineMessageHook:(message,onNotFound=this.args.onHandleMessageHookIdNotFound)=>{const attemptedHookID=message.tuiHookIdentity;if(attemptedHookID){let hook=this.#identifiables[attemptedHookID];return hook||(hook=onNotFound(message,attemptedHookID,this)),hook}return this.args.onHandleMessageHookIdNotProvided(message,this)},onDuplicateControlHook:(newHook,existingHook,identity)=>(console.warn(`[UserAgentBus.register] duplicate controlHook '${identity}' registered.`,newHook,existingHook,identity),newHook),onHandleMessageHookIdNotProvided:message=>{console.warn("[UserAgentBus.onHandleMessageHookIdNotProvided] controlHook ID not provided in message (expecting message.tuiHookIdentity property).",message,this.identifiables)},onHandleMessageHookIdNotFound:(message,attemptedHookID)=>{console.warn(`[UserAgentBus.onHandleMessageHookIdNotFound] controlHook ID '${attemptedHookID}' in message not found.`,message,this.identifiables)}}}),this.#clientReqMessageBaseURL=this.#config.args.clientReqMessageBaseURL,!this.#clientReqMessageBaseURL)throw Error("this.#config.args.clientReqMessageBaseURL expected in new UserAgentBus({ clientReqMessageBaseURL: ? })")}get clientReqMessageBaseURL(){return this.#clientReqMessageBaseURL}get config(){return this.#config}get args(){return this.#config.args}get registry(){return this.#registry}get domElemHookName(){return this.#config.args.domElemHookName}get discoverDomElemHook(){return this.#config.args.discoverDomElemHook}get identifiables(){return this.#identifiables}get prepareClientReqMessage(){return this.#config.args.prepareClientReqMessage}register(constructedHook){let registeredHook=constructedHook;const identity=registeredHook.identity;if(this.#registry.push(registeredHook),identity){const existing=this.#identifiables[identity];if(existing&&this.args.onDuplicateControlHook&&(registeredHook=this.args.onDuplicateControlHook(registeredHook,existing,identity)),registeredHook){this.#identifiables[identity]=registeredHook;const{operationsEE:operationsEE}=registeredHook;operationsEE.on("user-agent-request",(message=>{this.sendClientReqMessage(registeredHook,message,!0)})),operationsEE.on("user-agent-notification",(message=>{this.sendClientReqMessage(registeredHook,message,!1)})),operationsEE.emit("registered",{uab:this,identity:identity})}}return this}sendClientReqMessage(hook,message1,fullDuplex){const endpoint=this.#clientReqMessageBaseURL,payload=this.prepareClientReqMessage(hook,{...message1,transactionID:"TODO:UUIDv5?",endpoint:endpoint,clientProvenance:"UserAgentBus.sendClientMessage",uab:this});console.log("[UserAgentBus.sendClientMessage]",payload);const body=JSON.stringify(payload);fullDuplex?fetch(endpoint,{method:"POST",body:body}).then((res=>res.json())).then((message=>{hook.operationsEE.emit("user-agent-server-response",{...message,transactionID:"TODO:UUIDv5?",endpoint:endpoint,clientProvenance:"UserAgentBus.sendClientMessage",uab:this})})).catch((error=>{hook.operationsEE.emit("user-agent-request-error",{body:body,error:error,transactionID:"TODO:UUIDv5?",uab:this}),console.error(`${endpoint} POST error`,body,error)})):fetch(endpoint,{method:"POST",body:body}).catch((error=>{hook.operationsEE.emit("user-agent-notification-error",{body:body,error:error,transactionID:"TODO:UUIDv5?",uab:this}),console.error(`${endpoint} POST error`,body,error)}))}handleServerMessage(message,onNotFound){const hook=this.args.determineMessageHook(message,onNotFound);if(hook){const clientProvenance="UserAgentBus.handleServerMessage";hook.operationsEE.emit("server-notification",{...message,endpoint:endpoint,clientProvenance:clientProvenance,uab:this})}}async init(){return console.log("[UserAgentBus.init]",this),this}}export{UserAgentBus};function markdownItTransformer(){return{dependencies:void 0,acquireDependencies:async transformer=>{const{default:markdownIt}=await import("https://jspm.dev/markdown-it@12.2.0");return{markdownIt:markdownIt,plugins:await transformer.plugins()}},construct:async transformer=>{transformer.dependencies||(transformer.dependencies=await transformer.acquireDependencies(transformer));const markdownIt=transformer.dependencies.markdownIt({html:!0,linkify:!0,typographer:!0});return transformer.customize(markdownIt,transformer),markdownIt},customize:(markdownIt,transformer)=>{const plugins=transformer.dependencies.plugins;return markdownIt.use(plugins.footnote),transformer},unindentWhitespace:(text,removeInitialNewLine=!0)=>{const whitespace=text.match(/^[ \t]*(?=\S)/gm),indentCount=whitespace?whitespace.reduce(((r,a)=>Math.min(r,a.length)),1/0):0,regex=new RegExp(`^[ \\t]{${indentCount}}`,"gm"),result=text.replace(regex,"");return removeInitialNewLine?result.replace(/^\n/,""):result},plugins:async()=>{const{default:footnote}=await import("https://jspm.dev/markdown-it-footnote@3.0.3");return{footnote:footnote,adjustHeadingLevel:(md,options)=>{function getHeadingLevel(tagName){return"h"===tagName[0].toLowerCase()&&(tagName=tagName.slice(1)),parseInt(tagName,10)}const firstLevel=options.firstLevel;if("string"==typeof firstLevel&&(firstLevel=getHeadingLevel(firstLevel)),!firstLevel||isNaN(firstLevel))return;const levelOffset=firstLevel-1;levelOffset<1||levelOffset>6||md.core.ruler.push("adjust-heading-levels",(function(state){const tokens=state.tokens;for(let i=0;i<tokens.length;i++){if("heading_close"!==tokens[i].type)continue;const headingOpen=tokens[i-2],headingClose=tokens[i],currentLevel=getHeadingLevel(headingOpen.tag),tagName="h"+Math.min(currentLevel+levelOffset,6);headingOpen.tag=tagName,headingClose.tag=tagName}}))}}}}}async function renderMarkdown(strategies,mditt=markdownItTransformer()){const markdownIt=await mditt.construct(mditt);for await(const strategy of strategies(mditt)){const markdown=mditt.unindentWhitespace(await strategy.markdownText(mditt));strategy.renderHTML(markdownIt.render(markdown),mditt)}}function importMarkdownContent(input,select,inject){fetch(input).then((resp=>{resp.text().then((html=>{const foreignDoc=(new DOMParser).parseFromString(html,"text/html"),selected=select(foreignDoc);if(Array.isArray(selected))for(const s of selected){const importedNode=document.adoptNode(s);inject(importedNode,input,html)}else if(selected){const importedNode=document.adoptNode(selected);inject(importedNode,input,html)}}))}))}async function transformMarkdownElemsCustom(srcElems,finalizeElemFn,mditt=markdownItTransformer()){await renderMarkdown((function*(){for(const elem of srcElems)yield{markdownText:async()=>{if(elem.dataset.transformableSrc){const response=await fetch(elem.dataset.transformableSrc);return response.ok?await response.text():`Error fetching ${elem.dataset.transformableSrc}: ${response.status}`}return elem.innerText},renderHTML:async html=>{try{const formatted=document.createElement("div");formatted.innerHTML=html,elem.parentElement.replaceChild(formatted,elem),finalizeElemFn&&finalizeElemFn(formatted,elem)}catch(error){console.error("Undiagnosable error in renderHTML()",error)}}}}),mditt)}async function transformMarkdownElems(firstHeadingLevel=2){const mdittDefaults=markdownItTransformer();await transformMarkdownElemsCustom(document.querySelectorAll('[data-transformable="markdown"]'),((mdHtmlElem,mdSrcElem)=>{mdHtmlElem.dataset.transformedFrom="markdown",mdSrcElem.className&&(mdHtmlElem.className=mdSrcElem.className),document.dispatchEvent(new CustomEvent("transformed-markdown",{detail:{mdHtmlElem:mdHtmlElem,mdSrcElem:mdSrcElem}}))}),{...mdittDefaults,customize:(markdownIt,transformer)=>{mdittDefaults.customize(markdownIt,transformer),markdownIt.use(transformer.dependencies.plugins.adjustHeadingLevel,{firstLevel:firstHeadingLevel})}})}export{markdownItTransformer};export{renderMarkdown};export{importMarkdownContent};export{transformMarkdownElemsCustom};export{transformMarkdownElems};