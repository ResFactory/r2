import { fs, path } from "../render/deps.ts";
import * as SQLa from "../render/mod.ts";
import * as dv from "./data-vault.ts";

export function deviceFileSysModels<Context extends SQLa.SqlEmitContext>() {
  const stso = SQLa.typicalSqlTextSupplierOptions<Context>();
  const dvg = dv.dataVaultGovn<Context>(stso);

  const { text, unique } = dvg.domains;

  const deviceHub = dvg.hubTable("device", {
    hub_device_id: dvg.digestPrimaryKey(),
    host: unique(text()),
    host_ipv4_address: unique(text()),
  }, { pkDigestColumns: ["host", "host_ipv4_address"] });

  const deviceFileHub = dvg.hubTable("device_file", {
    hub_device_file_id: dvg.digestPrimaryKey(),
    abs_path: unique(text()),
  }, { pkDigestColumns: ["abs_path"] });

  const deviceFileLink = dvg.linkTable("device_file", {
    link_device_file_id: dvg.digestPrimaryKey(),
    hub_device_id: deviceHub.foreignKeyRef.hub_device_id(),
    hub_device_file_id: deviceFileHub.foreignKeyRef.hub_device_file_id(),
  });

  // deno-fmt-ignore
  const seedDDL = SQLa.SQL<Context>(stso)`
    -- Generated by ${path.basename(import.meta.url)}. DO NOT EDIT.

    ${dvg.sqlTextLintSummary}

    ${deviceHub}

    ${deviceFileHub}

    ${deviceFileLink}

    ${dvg.sqlTmplEngineLintSummary}
    ${dvg.sqlTextLintSummary}`;

  return {
    stso,
    dvg,
    deviceHub,
    deviceFileHub,
    deviceFileLink,
    seedDDL,
    isValid: () => {
      const stls = seedDDL.stsOptions.sqlTextLintState;
      if (stls?.lintedSqlText.lintIssues.find((li) => stls.isFatalIssue(li))) {
        return 100;
      }
      if (
        stls?.lintedSqlTmplEngine.lintIssues.find((li) => stls.isFatalIssue(li))
      ) {
        return 101;
      }
      return true;
    },
  };
}

export interface WalkGlob {
  readonly rootPath: string;
  readonly label: string;
  readonly glob: string;
  readonly include: (we: fs.WalkEntry) => boolean;
  readonly options?: (path: string) => fs.ExpandGlobOptions;
}

export function deviceFileSysContent<Context extends SQLa.SqlEmitContext>() {
  const fsm = deviceFileSysModels<Context>();
  const { deviceHub, deviceFileHub, deviceFileLink } = fsm;

  return {
    models: fsm,
    walkFilesGlob: (
      rootPath: string,
      inherit?: Partial<Omit<WalkGlob, "rootPath">>,
    ): WalkGlob => {
      return {
        rootPath,
        label: inherit?.label ?? rootPath,
        glob: inherit?.glob ?? "**/*",
        include: inherit?.include ?? ((we) => we.isFile),
        options: inherit?.options ?? ((path) => ({
          root: path,
          includeDirs: false,
          globstar: true,
          extended: true,
          exclude: [".git"],
        })),
      };
    },
    entriesDML: async (ctx: Context, ...globs: WalkGlob[]) => {
      const uniqueDML = new Set<string>();
      const memoizeSQL = <STS extends SQLa.SqlTextSupplier<Context>>(
        sts: STS,
      ) => {
        uniqueDML.add(sts.SQL(ctx));
        return sts;
      };

      const activeHost = memoizeSQL(
        await deviceHub.insertDML({
          host: Deno.hostname(),
          host_ipv4_address: Deno.hostname(), // TODO: add IPv4 address
        }),
      );
      const { hub_device_id } = activeHost.returnable(activeHost.insertable);

      for (const srcGlob of globs) {
        for await (
          const we of fs.expandGlob(
            srcGlob.glob,
            srcGlob.options?.(srcGlob.rootPath),
          )
        ) {
          const dfDML = memoizeSQL(
            await deviceFileHub.insertDML({ abs_path: we.path }),
          );
          const { hub_device_file_id } = dfDML.returnable(
            dfDML.insertable,
          );
          memoizeSQL(
            await deviceFileLink.insertDML({
              hub_device_id,
              hub_device_file_id,
            }),
          );
        }
      }
      return uniqueDML;
    },
  };
}

export async function deviceFileSysDV(emitForSqlite3IMDB: boolean) {
  const ctx = SQLa.typicalSqlEmitContext();
  type Context = typeof ctx;

  const fsc = deviceFileSysContent<Context>();
  console.log(fsc.models.seedDDL.SQL(ctx));

  const isValid = fsc.models.isValid();
  if (typeof isValid === "number") {
    console.error("FATAL errors in SQL (see lint messages in emitted SQL)");
    Deno.exit(isValid);
  }

  (await fsc.entriesDML(
    ctx,
    fsc.walkFilesGlob(path.resolve(
      path.dirname(path.fromFileUrl(import.meta.url)),
      "..",
      "..",
      "..",
    )),
  )).forEach((sql) => console.log(sql, ";"));

  // this is so that sqlite3 ":memory:" is dumped to STDOUT for subsequent sqlite3 lib/sql/models/fs.db
  if (emitForSqlite3IMDB) console.log(`.dump`);
}

if (import.meta.main) {
  // - if we're being called as a CLI, just emit the DDL SQL:
  //   $ deno run -A --unstable lib/sql/models/fs.ts | sqlite3 ":memory:" > synthetic.sql
  //   $ deno run -A --unstable lib/sql/models/fs.ts | sqlite3 ":memory:" | sqlite3 test.db
  // - sending into SQLite memory first and then dumping afterwards is much faster
  //   because we're using static SQL with lookups for foreign keys.
  // - A good way to "test" is to use this CLI from $RF_HOME:
  //   $ sudo apt-get -y -qq install sqlite3
  //   $ rm -f lib/sql/models/fs.db && deno run -A --unstable lib/sql/models/fs.ts | sqlite3 ":memory:" | sqlite3 lib/sql/models/fs.db
  //   then, open `fs.sql` with VS Code SQL notebook for exploring the content
  await deviceFileSysDV(true);
}
