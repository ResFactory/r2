import { fs, path } from "../render/deps.ts";
import * as SQLa from "../render/mod.ts";
import * as typ from "./typical.ts";

// deno-lint-ignore no-explicit-any
type Any = any;

export interface WalkGlob {
  readonly originRootPath: string;
  readonly glob: string;
  readonly include: (we: fs.WalkEntry) => boolean;
  readonly options?: (path: string) => fs.ExpandGlobOptions;
}

export enum FileSystemEntryNature {
  PATH,
  FILE,
  // TODO: SYMLINK
}

export function fileSystemModels<Context extends SQLa.SqlEmitContext>(
  ddlOptions: SQLa.SqlTextSupplierOptions<Context> & {
    readonly sqlNS?: SQLa.SqlNamespaceSupplier;
  } = SQLa.typicalSqlTextSupplierOptions(),
) {
  const mg = typ.typicalModelsGovn(ddlOptions);

  const fseNature = mg.enumTable(
    "fs_entry_nature",
    FileSystemEntryNature,
  );

  const fsOrigin = mg.table("fs_origin", {
    fs_origin_id: mg.ulidPrimaryKey(),
    host: SQLa.unique(SQLa.text()), // add label "surrogate key"
    host_meta: SQLa.jsonTextNullable(),
    ...mg.housekeeping(),
  });

  // TODO: create unique index for fs_origin_id, label
  const fsEntryPK = mg.primaryKey();
  const fsEntry = mg.table("fs_entry", {
    fs_entry_id: fsEntryPK,
    fse_nature_id: fseNature.foreignKeyRef.code(),
    fs_origin_id: fsOrigin.foreignKeyRef.fs_origin_id(),
    parent_id: SQLa.selfRefForeignKeyNullable(fsEntryPK),
    label: SQLa.text(), // how the entry is known, abs_path for a directory, file_abs_path_and_file_name_extn for file
    ...mg.housekeeping(),
  });

  // TODO: create unique index for fs_origin_id, abs_path
  const fsePathPK = mg.primaryKey();
  const fsePath = mg.table("fs_entry_path", {
    fs_entry_path_id: fsePathPK,
    fs_origin_id: fsOrigin.foreignKeyRef.fs_origin_id(SQLa.belongsTo()), // TODO: add label "denormalized"
    fs_entry_id: fsEntry.foreignKeyRef.fs_entry_id(SQLa.belongsTo()), // TODO: belongsTo should be isA(), requires 1:1
    parent_id: SQLa.selfRefForeignKeyNullable(fsePathPK),
    abs_path: SQLa.text(),
    parent_abs_path: SQLa.textNullable(), // TODO: add governance details such as "denormalized"
    ...mg.housekeeping(),
  });

  // TODO: create unique index for fs_origin_id, file_extn, file_extn_modifiers
  const fseFileExtn = mg.table("fs_entry_file_extn", {
    fs_entry_file_extn_id: mg.primaryKey(),
    fs_origin_id: fsOrigin.foreignKeyRef.fs_origin_id(),
    file_extn: SQLa.text(),
    file_extn_modifiers: SQLa.textNullable(),
    ...mg.housekeeping(),
  });

  const fseFilePK = mg.primaryKey();
  const fseFile = mg.table("fs_entry_file", {
    fs_entry_file_id: fseFilePK,
    fs_entry_id: fsEntry.foreignKeyRef.fs_entry_id(SQLa.belongsTo()), // TODO: belongsTo should be isA(), requires 1:1
    fse_path_id: fsePath.foreignKeyRef.fs_entry_path_id(SQLa.belongsTo()),
    file_abs_path_and_file_name_extn: SQLa.text(),
    file_parent_path: SQLa.text(), // TODO: add "denormalized" label
    file_root: SQLa.textNullable(),
    file_abs_path_only: SQLa.text(),
    file_name_without_extn: SQLa.text(),
    file_name_with_extn: SQLa.text(),
    file_extn: SQLa.textNullable(),
    file_extn_modifiers: SQLa.textNullable(),
    ...mg.housekeeping(),
  });

  const fsWalk = mg.table("fs_walk", {
    fs_walk_id: mg.primaryKey(),
    fs_origin_id: fsOrigin.foreignKeyRef.fs_origin_id(),
    fs_path_id: fsePath.foreignKeyRef.fs_entry_path_id(),
    glob: SQLa.text(),
    ...mg.housekeeping(),
  });

  const fsWalkEntry = mg.table("fs_walk_entry", {
    fs_walk_entry_id: mg.primaryKey(),
    fs_walk_id: fsWalk.foreignKeyRef.fs_walk_id(SQLa.belongsTo()),
    fs_entry_id: fsEntry.foreignKeyRef.fs_entry_id(SQLa.belongsTo()),
    label: SQLa.text(), // how the entry is known, abs_path for a directory, file_abs_path_and_file_name_extn for file
    ...mg.housekeeping(),
  });

  // deno-fmt-ignore
  const seedDDL = SQLa.SQL<Context>(ddlOptions)`
      -- Generated by ${path.basename(import.meta.url)}. DO NOT EDIT.

      ${mg.sqlTextLintSummary}

      ${fseNature}

      ${fseNature.seedDML}

      ${fsOrigin}

      ${fsEntry}

      ${fsePath}

      ${fseFileExtn}

      ${fseFile}

      ${fsWalk}

      ${fsWalkEntry}

      ${mg.sqlTmplEngineLintSummary}`;

  return {
    modelsGovn: mg,
    fseNature,
    fsOrigin,
    fsEntry,
    fsePath,
    fseFileExtn,
    fseFile,
    fsWalk,
    fsWalkEntry,
    seedDDL,
    walkedDML: async (ctx: Context, ...globs: WalkGlob[]) => {
      const result = new Set<string>();
      const storeSQL = <STS extends SQLa.SqlTextSupplier<Context>>(
        sts: STS,
      ) => {
        result.add(sts.SQL(ctx));
        return sts;
      };

      const activeHost = await fsOrigin.prepareRecord({
        host: Deno.hostname(),
      });
      //fsOrigin.default
      const { fs_origin_id } = activeHost;
      storeSQL(fsOrigin.insertDML(activeHost));

      const storePathSQL = (absPath: string) => {
        const entryDML = storeSQL(fsEntry.insertDML({
          fse_nature_id: FileSystemEntryNature.PATH,
          label: absPath,
          fs_origin_id,
        }));
        return [
          entryDML,
          storeSQL(fsePath.insertDML({
            fs_entry_id: fsEntry.select(entryDML.insertable),
            fs_origin_id,
            abs_path: absPath,
          })),
        ];
      };

      for (const srcGlob of globs) {
        const [_, walkRootPathDML] = storePathSQL(srcGlob.originRootPath);
        const walkDML = storeSQL(fsWalk.insertDML({
          fs_path_id: fsePath.select(walkRootPathDML.insertable),
          fs_origin_id,
          glob: srcGlob.glob,
        }));
        for await (
          const we of fs.expandGlob(
            srcGlob.glob,
            srcGlob.options?.(srcGlob.originRootPath),
          )
        ) {
          if (srcGlob.include(we) && we.isFile) {
            const [pathEntryDML, pathDML] = storePathSQL(path.dirname(we.path));
            const fileEntryDML = storeSQL(fsEntry.insertDML({
              fse_nature_id: FileSystemEntryNature.FILE,
              label: we.path,
              fs_origin_id,
            }));
            // const fileDML = storeSQL(fseFile.insertDML({

            // }))
          }
        }
      }
      return result;
    },
  };
}

if (import.meta.main) {
  // if we're being called as a CLI, just emit the DDL SQL:
  //    deno run -A --unstable lib/sql/models/fs.ts | sqlite3 ":memory:" > synthetic.sql
  //    deno run -A --unstable lib/sql/models/fs.ts | sqlite3 ":memory:" | sqlite3 test.db
  // sending into SQLite memory first and then dumping afterwards is much faster
  const dbDefn = fileSystemModels();
  const ctx = SQLa.typicalSqlEmitContext();
  console.log(dbDefn.seedDDL.SQL(ctx));
  (await dbDefn.walkedDML(ctx, {
    originRootPath: path.resolve(
      path.dirname(path.fromFileUrl(import.meta.url)),
      "../..",
    ),
    glob: "**/*",
    include: (we) => we.isFile,
    options: (path) => ({
      root: path,
      includeDirs: false,
      globstar: true,
    }),
  })).forEach((sql) => console.log(sql, ";"));
  console.log(".dump");
}
