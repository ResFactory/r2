//! This Typescript module serves as both a template from which Typescript code
//! is generated and an importable module that can be used as-is.
//!
//! To support Typescript code generation, any line that starts with //! is removed
//! when code is generated (treated as a "template comment") but all other
//! Typescript is retained. The following are special replacements:
//! * ${SQL_RENDER_EMIT_TS_ORIGIN} will be replaced with what's passed into generator
//! * The first line starting with double-slash and ${SQL_RENDER_EMIT_TS_BODY}`
//!   will be replaced with the template body
//!
// Generated by ${SQL_RENDER_EMIT_TS_ORIGIN}. DO NOT EDIT.
// Template: RF_HOME/lib/sql/render/template/emittable-typescript.ts

// deno-lint-ignore no-explicit-any
type Any = any; // to ease lint warnings

export type CamelCase<S extends string> = S extends
  `${infer P1}_${infer P2}${infer P3}`
  ? `${Lowercase<P1>}${Uppercase<P2>}${CamelCase<P3>}`
  : Lowercase<S>;

export type TableToObject<T> = {
  [K in keyof T as CamelCase<string & K>]: T[K] extends Date ? T[K]
    : // deno-lint-ignore ban-types
    (T[K] extends object ? TableToObject<T[K]> : T[K]);
};

export type RequireOnlyOne<T, Keys extends keyof T = keyof T> =
  & Pick<T, Exclude<keyof T, Keys>>
  & {
    [K in Keys]-?:
      & Required<Pick<T, K>>
      & Partial<Record<Exclude<Keys, K>, undefined>>;
  }[Keys];

export interface SqlObjectNamingStrategy {
  readonly tableName: (tableName: string) => string;
  readonly tableColumnName: (
    tc: { tableName: string; columnName: string },
  ) => string;
}

export interface SqlObjectNamingStrategySupplier<Context> {
  (
    ctx: Context,
    nsOptions?: SqlObjectNamingStrategyOptions<Context>,
  ): SqlObjectNamingStrategy;
}

export interface SqlObjectNamingStrategyOptions<Context> {
  readonly quoteIdentifiers: boolean;
}

export interface SqlTextEmitOptions<Context> {
  readonly namingStrategy: SqlObjectNamingStrategySupplier<Context>;
  readonly quotedLiteral: (value: unknown) => [value: unknown, quoted: string];
}

export interface SqlTextSupplier<
  Context,
  EmitOptions extends SqlTextEmitOptions<Context>,
> {
  readonly SQL: (ctx?: Context, options?: EmitOptions) => string;
}

export type InsertStmtReturning<
  ReturnableRecord,
  ReturnableColumnName extends keyof ReturnableRecord = keyof ReturnableRecord,
  ReturnableColumnExpr extends string = string,
> =
  | "*"
  | "primary-keys"
  | RequireOnlyOne<{
    readonly columns?: ReturnableColumnName[];
    readonly exprs?: ReturnableColumnExpr[];
  }>;

export interface InsertStmtPreparer<
  Context,
  TableName extends string,
  PrimaryKeyColName extends string,
  InsertableRecord,
  ReturnableRecord,
  EmitOptions extends SqlTextEmitOptions<Context>,
  InsertableColumnName extends keyof InsertableRecord = keyof InsertableRecord,
  ReturnableColumnName extends keyof ReturnableRecord = keyof ReturnableRecord,
  ReturnableColumnExpr extends (keyof ReturnableRecord | string) =
    (keyof ReturnableRecord | string),
> {
  (ir: InsertableRecord, options?: {
    readonly emitColumn?: (
      columnName: keyof InsertableRecord,
      record: InsertableRecord,
      tableName: TableName,
      ns: SqlObjectNamingStrategy,
      eo?: EmitOptions,
      ctx?: Context,
    ) =>
      | [columNameSqlText: string, value: unknown, valueSqlText: string]
      | undefined;
    readonly where?:
      | SqlTextSupplier<Context, EmitOptions>
      | ((
        ctx?: Context,
        eo?: EmitOptions,
      ) => SqlTextSupplier<Context, EmitOptions>);
    readonly onConflict?:
      | SqlTextSupplier<Context, EmitOptions>
      | ((
        ctx?: Context,
        eo?: EmitOptions,
      ) => SqlTextSupplier<Context, EmitOptions>);
    readonly returning?:
      | InsertStmtReturning<ReturnableRecord>
      | ((
        ctx?: Context,
        eo?: EmitOptions,
      ) => InsertStmtReturning<ReturnableRecord>);
    readonly transformSQL?: (
      suggested: string,
      tableName: TableName,
      record: InsertableRecord,
      names: InsertableColumnName[],
      values: [value: unknown, sqlText: string][],
      ns: SqlObjectNamingStrategy,
      eo?: EmitOptions,
      ctx?: Context,
    ) => string;
  }): SqlTextSupplier<Context, EmitOptions>;
}

export function typicalInsertStmtPreparer<
  Context,
  TableName extends string,
  PrimaryKeyColName extends string,
  InsertableRecord,
  ReturnableRecord,
  EmitOptions extends SqlTextEmitOptions<Context>,
  InsertableColumnName extends keyof InsertableRecord = keyof InsertableRecord,
  ReturnableColumnExpr extends (keyof ReturnableRecord | string) =
    (keyof ReturnableRecord | string),
>(
  tableName: TableName,
  candidateColumns: InsertableColumnName[],
  pkColumns?: PrimaryKeyColName[],
): InsertStmtPreparer<
  Context,
  TableName,
  PrimaryKeyColName,
  InsertableRecord,
  ReturnableRecord,
  EmitOptions
> {
  return (ir, pisOptions) => {
    return {
      SQL: (ctx, eo) => {
        const { emitColumn, returning: returningArg, where, onConflict } =
          pisOptions ?? {};
        const ns = eo?.namingStrategy(ctx ?? ({} as Context), {
          quoteIdentifiers: true,
        }) ??
          quotedIdentifiersNS;
        const names: InsertableColumnName[] = [];
        const values: [value: unknown, valueSqlText: string][] = [];
        candidateColumns.forEach((c) => {
          let ec: [
            columNameSqlText: string,
            value: unknown,
            valueSqlText: string,
          ] | undefined;
          if (emitColumn) {
            ec = emitColumn(c, ir, tableName, ns, eo, ctx);
          } else {
            const { quotedLiteral = typicalQuotedLiteral } = eo ?? {};
            const qValue = quotedLiteral((ir as Any)[c]);
            ec = [c as string, ...qValue];
          }
          if (ec) {
            const [columNameSqlText, value, valueSqlText] = ec;
            names.push(columNameSqlText as InsertableColumnName);
            values.push([value, valueSqlText]);
          }
        });
        const sqlText = (
          ss?:
            | SqlTextSupplier<Context, EmitOptions>
            | ((
              ctx?: Context,
              eo?: EmitOptions,
            ) => SqlTextSupplier<Context, EmitOptions>),
        ) => {
          if (!ss) return "";
          const SQL = typeof ss == "function"
            ? ss(ctx, eo).SQL(ctx, eo)
            : ss.SQL(ctx, eo);
          return ` ${SQL}`;
        };
        const returning = returningArg
          ? (typeof returningArg === "function"
            ? returningArg(ctx, eo)
            : returningArg)
          : undefined;
        let returningSQL = "";
        if (typeof returning === "string") {
          switch (returning) {
            case "*":
              returningSQL = ` RETURNING *`;
              break;
            case "primary-keys":
              returningSQL = ` RETURNING ${
                pkColumns!.map((n) =>
                  ns.tableColumnName({ tableName, columnName: String(n) })
                ).join(", ")
              }`;
              break;
          }
        } else if (typeof returning === "object") {
          if (returning.columns) {
            returningSQL = ` RETURNING ${
              returning!.columns!.map((n) =>
                ns.tableColumnName({ tableName, columnName: String(n) })
              ).join(", ")
            }`;
          } else {
            returningSQL = ` RETURNING ${
              returning!.exprs!.map((n) =>
                ns.tableColumnName({ tableName, columnName: String(n) })
              ).join(", ")
            }`;
          }
        }
        // deno-fmt-ignore
        const SQL = `INSERT INTO ${ns.tableName(tableName)} (${names.map(n => ns.tableColumnName({ tableName, columnName: String(n) })).join(", ")}) VALUES (${values.map((value) => value[1]).join(", ")
          })${sqlText(where)}${sqlText(onConflict)}${returningSQL}`;
        return pisOptions?.transformSQL
          ? pisOptions?.transformSQL(
            SQL,
            tableName,
            ir,
            names,
            values,
            ns,
            eo,
            ctx,
          )
          : SQL;
      },
    };
  };
}

export interface GovernedTable<TableName> {
  readonly tableName: TableName;
}

export interface TableDataTransferSuppliers<
  TableName,
  TableRecord,
  TsObject,
  InsertableRecord,
  InsertableObject,
> extends GovernedTable<TableName> {
  readonly fromTable: (t: TableRecord) => TsObject;
  readonly toTable: (o: TsObject) => TableRecord;
  readonly insertable: (o: InsertableObject) => InsertableRecord;
}

export interface TableDmlSuppliers<
  Context,
  TableName extends string,
  PrimaryKeyColName extends string,
  InsertableRecord,
  ReturnableRecord,
  EmitOptions extends SqlTextEmitOptions<Context>,
> extends GovernedTable<TableName> {
  readonly prepareInsertStmt: InsertStmtPreparer<
    Context,
    TableName,
    PrimaryKeyColName,
    InsertableRecord,
    ReturnableRecord,
    EmitOptions
  >;
}

// ${SQL_RENDER_EMIT_TS_BODY} each table will generate its own body

const quotedIdentifiersNS: SqlObjectNamingStrategy = {
  tableName: (name) => `"${name}"`,
  tableColumnName: (tc) => `"${tc.columnName}"`,
};

const bareIdentifiersNS: SqlObjectNamingStrategy = {
  tableName: (name) => name,
  tableColumnName: (tc) => tc.columnName,
};

export const typicalQuotedLiteral = (
  value: unknown,
): [value: unknown, quoted: string] => {
  if (typeof value === "undefined") return [value, "NULL"];
  if (typeof value === "string") {
    return [value, `'${value.replaceAll("'", "''")}'`];
  }
  return [value, String(value)];
};

export function typicalSqlEmitOptions<Context>(
  inherit?: SqlTextEmitOptions<Context>,
): SqlTextEmitOptions<Context> {
  return {
    quotedLiteral: typicalQuotedLiteral,
    namingStrategy: (_, nsOptions) =>
      nsOptions?.quoteIdentifiers ? quotedIdentifiersNS : bareIdentifiersNS,
    ...inherit,
  };
}
